#!/usr//bin/env raku

my $time = BEGIN { now }
END { say "Total execution time (s): " , now - INIT now }

say "Compile time: ", now - $time;

our constant OFE-PATH="%OFE-PATH%";

use OneFit;
use OneFit::Engine::Grammars;
use OneFit::Engine::Parameters;
use OneFit::Engine::Parfiles;
use OneFit::Engine::Stpfiles;
use OneFit::Engine::Stelar;
use Test;

use Cro::HTTP::Router;
use Cro::HTTP::Server;
use Cro::HTTP::Log::File;
use JSON::Fast;

my %*SUB-MAIN-OPTS =  :named-anywhere, :allow-no, :bundling ;

multi MAIN (Bool :h(:help($))) {
#        say 'onefite is a script that implements fitteia.org fitting settings and fitting strategies in the form of a fiiting engine access√≠ble from the command line';

#    my $p= shell "onefite", :err;
#    say $p.err.slurp(:close);
    note qq:to/END_USAGE/;
    Usage:
            onefite [-h|--help]
	    onefite uninstall
	    onefite service start
	    onefite service stop
	    onefite service log
	    onefite service PID
	    onefite list [-q|--quiet]
	    onefite list models
	    onefite path [-s|--src] [-t] [-e|--examples] [-b|--bin] [-l|--lib] [-c|-C] [--log]
	    onefite convert <input-file> <output-file> [--work-folder=<Str>]
	    onefite upgrade [-u|--to-user] [-c|--compile] [-d|--systemd-daemon] [--test=<Str>] [--ip=<Str>] [-p|--port[=Int]] [-m|--merge-site=<Str>] [--cernlib]
	    onefite start-web-engine [--ip[=Any]] [-p|--port[=Any]]
	    onefite stop-web-engine
	    onefite help <model> [-q|--quiet]
	    onefite help <model> <key>] [-q|--quiet]
	    onefite start-engine [--no-plot] [-q|--quiet] [--work-folder=<Str>]
            onefite create <function> [<data-files> ...] [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--stelar-hdf5] [--stelar-hdf5-Re] [--stelar-hdf5-Im] [--stelar-hdf5-R1] [--stelar-hdf5-R1-err=<Rat>] [--SymbSize|--ssz=<Str>] [--save-to|--to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
	    onefite random <function> [<data-files> ...] [--data-label|--data-labels=<Str>] [--tags=<Str>] [--zip-to=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--save-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
            onefite fit <function> [<data-files> ...] [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--zip-to=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--stelar-hdf5] [--stelar-hdf5-Re] [--stelar-hdf5-Im] [--stelar-hdf5-R1] [--stelar-hdf5-R1-err=<Rat>] [--SymbSize|--ssz=<Str>] [--save-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
	    onefite fit <input-file> [--fit-methods=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--save-to|--to=<Str>] [--zip-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
	    onefite plot <input-file> [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--work-folder=<Str>] [--Num|--npts[=Int]]
	    onefite test list
	    onefite test [<arr> ...] [--verbose|-v]
  
	    <input-file>     name of the file to be converted (.sav or .json)
	    <output-file>    name of the converted file (.sav or .json)
	    fit-methods: simp scan min minos

	    <function> syntax alternatives:
    \"y(x,a,b,c)=a + b*x + c*pow(x,2.0)\"
    \"y(t,A,lambda: 0.1)=A*exp(-lambda*t)\" 0.1 is the initial value to start mimimization
    \"y (t,A,B=2,lambda)=A * (1 - B*exp(-lambda*t) )\" B is fixed with value 2
    \"y( t,A, lambda: [0;0.5])=A*exp(-lambda*t)\" [lambda is limited to range 0 to 0.
    \"R1(f:[0;1e9], A, tau[0<1e-9])=A*tau/(1+pow(2*pi*f*tau,2.0)\" f is limite to positive values up to 1e9 and tau also
    \"y[-1;1](x:[0<1],a,b,c)=a + b*x + c*x*x\" theoretical curves generated for x is limited to range 0 to 1; in the plot y axis will be limited to range -1 to 1
    \"f(x,p1: 2, p2=0.3, p3[5<10]) :[-5;5]=p1*exp(-p2*x)*sin(2*pi*x/p3)\" p1 is initialized to 1, p2 is fixed to 2 p3 will be in the range 5 to 10
END_USAGE
}

multi MAIN ('list',
      	   Bool :q(:$quiet) = False
	   ){
#    my @list = dir(::('OFE-PATH') ~ "/C/local");
#    @list.push: dir(::('OFE-PATH') ~ "/C/core/onefit-3.1/modelos").Slip;
#    @list = @list.grep(*.f).grep(/\.c/)>>.basename>>.IO>>.extension('').sort;
#    my $txt = "OneFit Engine Models Library:\n";
#    $txt ~= @list.join("\n");
     my $txt = "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp;
    say $txt unless $quiet;
    $txt;
}

multi MAIN ('list','models',
	   ){
	   MAIN('list');
}

multi MAIN ('list','alias',
	   ){
	say "{ ::('OFE-PATH') }/../etc/alias.json".IO.slurp  if  "{ ::('OFE-PATH') }/../etc/alias.json".IO.e;
}

multi MAIN ('convert',
	    Str $input-file where { $input-file.IO.e or die "$input-file dosen't exist!" }, #= name of the file to be converted (.sav or .json)
	    Str $output-file, #= name of the converted file (.sav or .json)
            Str :$work-folder = "."
	   ) {
    my $eng = Engine.new.path($work-folder).read($input-file).blocks(:r).parameters(:r).functions(:r).code(:write,:compile).save($output-file);
    return 0;
}

multi MAIN ('path',
      Bool :s(:$src) = False,
      Bool :$t = False,
      Bool :e(:$examples) = False,
      Bool :b(:$bin) = False,
      Bool :l(:$lib) = False,	
      Bool :c(:$C) = False,
      Bool :$log = False
      ){
      if none($src,$t,$bin,$lib,$C,$examples) {
      	 say ::('OFE-PATH');
	 say ::('OFE-PATH') ~ "/t";
	 say ::('OFE-PATH') ~ "/examples";
	 say ::('OFE-PATH') ~ "/lib";
	 say ::('OFE-PATH') ~ "/bin";
	 say ::('OFE-PATH') ~ "/../bin";
	 say ::('OFE-PATH') ~ "/../log";
	 say ::('OFE-PATH') ~ "/C";
      }
      else {
      	 say ::('OFE-PATH') if $src;
	 say ::('OFE-PATH') ~ "/t" if $t;
	 say ::('OFE-PATH') ~ "/examples" if $examples;
	 say ::('OFE-PATH') ~ "/lib" if $lib;
	 say ::('OFE-PATH') ~ "/../bin" if $bin;
	 say ::('OFE-PATH') ~ "/../log" if $log;
	 say ::('OFE-PATH') ~ "/C" if $C;
      }
}

multi MAIN ('upgrade',
      Bool :u(:$to-user) = False,
      Bool :c(:$compile) = True,
      Bool :d(:$systemd-daemon) = False,
      Bool :$cernlib = False,
      Str  :$ip = '*',
      Int  :p(:$port) = 8142,
      Str  :$test = '--/test',
      Str  :m(:$merge-site) = '',
      ){
      shell "sudo service onefite stop" if $systemd-daemon and !$to-user and shell("sudo systemctl list-units | awk \'/^onefite/ \{print \$1\}\'",:out).out.slurp.Bool;
      
      shell "cd $*HOME/.local/OneFit-Engine && git stash && git pull && ./INSTALL { ($to-user) ?? '--to-user' !! '' } { '-/c' unless $compile } { '-d' if $systemd-daemon } $test --ip=$ip --port=$port { ($merge-site.Bool) ?? '-m=' ~ $merge-site !! '' } { '--cernlib' if $cernlib } ";
      MAIN('service','start',:systemd-daemon(all($systemd-daemon,!$to-user)),ip => $ip, port => $port)
}

multi MAIN ('uninstall'){
      MAIN('stop-web-engine');
      shell "cd $*HOME/.local/OneFit-Engine && git stash && git pull && ./INSTALL -U";
      exit;  
}

multi MAIN ('service','start',	
      Bool :d(:$systemd-daemon) = False,
      Str  :$ip = '*',
      Int  :p(:$port) = 8142,
      ) {
      if $systemd-daemon {
           say "stoping onefite service...";
      	   my $proc = shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1];
      	   shell "sudo kill -9 $proc" if so $proc;
           shell 'sudo systemctl daemon-reload';
	   shell 'sudo systemctl enable onefite.service';
	   shell 'sudo service onefite start';
	   say "service onefite started on IPv4 $ip and port $port";
      }
      else {           
            say "stoping onefite service...";
      	    my $proc = shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1];
      	    shell "kill -9 $proc" if so $proc;
      	    say "starting onefite service on $*HOME/public_html and go in the backgound";
      	    shell "cd $*HOME/public_html; nohup onefite start-web-engine --ip=$ip --port=$port &";
      }
      exit
}

multi MAIN ('service','stop') { MAIN('stop-web-engine'); exit }

multi MAIN ('service','log') { "{ ::('OFE-PATH') }/../log/onefite".IO.slurp.say; exit }

multi MAIN ('service','PID') { shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1].say; exit }

multi MAIN ('stop-web-engine'){
      my $proc = shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1];
      shell "kill -9 $proc" if so $proc;
}

multi MAIN ('start-web-engine',
	    :$ip = from-json(shell("ip -4 -br -j add",:out).out.slurp(:close)).tail<addr_info>.head<local>,
	    :p(:$port) = 8142,   
	   ){
	   my $log-file="{ ::('OFE-PATH') }/../log/onefite";
	   my $log-fh = open($log-file, :a);
    my $application = route {
	   get -> {
	     $log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) get webform");
	     $log-fh.flush;

	       content 'text/html', q:to/HTML/;
               	<!DOCTYPE html>
            	<html>
           	 <head>
            	   <title>OneFit Engine Web Server</title>
            	 </head>
            	  <body>
            	     <h1>OneFit Engine Web Server</h1>

            	     <form action="/fit" method="post" enctype="multipart/form-data">
            	     Upload file [.json | .sav | .hdf5 | data-file ] <input type="file" name="file"><br/>
		       Download: <input type="text" name="download" value="zip"><br/>
		       Username: <input type="text" name="username" value="<username>"><br/>
		       Num points: <input type="text" name="Num" value="100"><br/>
		       Symbol size: <input type="text" name="SymbSize" value="1.0"><br/>
		       Fit methods: <input type="text" name="fit-methods" value="simp scan min minos"><br/>
		       Data file fitting function: <textarea rows="1" cols="100" name="function" value=""></textarea>
		       <table>
		       <tr><td></td><td>yes/no</td></tr>
		       <tr><td>global fit: </td><td><input name="global" type="radio" value="yes">/<input name="global" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>autox: </td><td><input name="autox" type="radio" value="yes">/<input name="autox" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>autoy: </td><td><input name="autoy" type="radio" value="yes">/<input name="autoy" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>autoxy: </td><td><input name="autoxy" type="radio" value="yes">/<input name="autoxy" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>logx: </td><td><input name="logx" type="radio" value="yes">/<input name="logx" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>logy: </td><td><input name="logy" type="radio" value="yes">/<input name="logy" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>stelar-hdf5: </td><td><input name="stelar-hdf5" type="radio" value="yes">/<input name="stelar-hdf5" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>stelar-hdf5-Re: </td><td><input name="stelar-hdf5-Re" type="radio" value="yes">/<input name="stelar-hdf5-Re" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>stelar-hdf5-Im: </td><td><input name="stelar-hdf5-Im" type="radio" value="yes">/<input name="stelar-hdf5-Im" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>stelar-hdf5-R1: </td><td><input name="stelar-hdf5-R1" type="radio" value="yes">/<input name="stelar-hdf5-R1" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>stelar-hdf5-R1-err: </td><td><input name="stelar-hdf5-R1-err" type="text" value="">(float number)</td></tr>
		       </table>
           	       <button type="submit">fit</button>
            	     </form>
            	     <form action="/convert" method="post" enctype="multipart/form-data">
           	       <button type="submit">convert</button>
            	     </form>
            	     <form action="/list" method="post" enctype="multipart/form-data">
           	       <button type="submit">list models</button>
            	     </form>
            	     <form action="/help" method="post" enctype="multipart/form-data">
           	       <button type="submit">help</button>
		       model: <input name="model" type="text" value="BPP" size=20>
		       key: <input name="key" type="text" values="" size=20>
            	     </form>

            	  </body>
            	 </html>
HTML
	}
	post -> 'list' {
	     $log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) list");
	     $log-fh.flush;
	     content 'text/plain', "{ MAIN('list',:quiet) }\n"	
	}	
	post -> 'help' {
            request-body -> (:$model, *%rest) {
	    	$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) help");
		$log-fh.flush;
	    	if so %rest.kv {
		   for %rest.kv -> $k,$v {
		       if so $v.Str { content 'text/plain', "{ MAIN('help',$model.Str, $v.Str, :quiet) }\n" }
		       else { content 'text/plain', "{ MAIN('help',$model.Str,:quiet) }\n" }
		   }
	    	}
		else { 	content 'text/plain', "{ MAIN('help',$model.Str,:quiet) }\n" }
	    }
	}	
	post -> 'fit',*@args {
            request-body -> (:$file, *%rest) {
	        my $username = "";
	        my $time = now;
    		my $filename = $file.filename;
		my $folder = $filename.IO.extension('').Str;
		my $zip-file = $filename.IO.extension('zip').Str;		
		my $file-to-download = ""; 
		my $function = "";
		my $autox = "";
		my $autoy = "";
		my $autoxy= "";
		my $logx= "";
		my $logy= "";
		my $global="";
		my $stelar-hdf5 = "";
		my $stelar-hdf5-Re = "";
		my $stelar-hdf5-Im = "";
		my $stelar-hdf5-R1 = "";
		my $stelar-hdf5-R1-err = "";
		my $num   = +100;
		my $ssz   = +1.0;
		my $fit-methods = "simp scan min minos";
		my $file-content = $file.body-blob;
		my $tmp-folder=10000;
		loop { $tmp-folder = 10000.rand.Int; last unless "./$tmp-folder".so.IO.e }
		my $work-folder = "./$tmp-folder";
#		$filename.IO.spurt: $file-content.decode('UTF-8');
		if so %rest.kv {
		   for %rest.kv -> $k, $v {
		       $fit-methods	      = $v.Str	   if $k eq "fit-methods";
		       $function      	      = $v.Str     if $k eq "function";
		       $num        	      = +$v.Str    if $k eq "Num";
		       $ssz		      = $v.Str	   if $k eq "SymbSize";
		       $username   	      = $v.Str     if $k eq "username";
		       $global      	      = "--global" if $k eq "global"  and $v eq any("yes",1);
		       $autox      	      = "--autox"  if $k eq "autox"  and $v eq any("yes",1);
		       $autoy      	      = "--autoy"  if $k eq "autoy"  and $v eq any("yes",1);
		       $autoxy     	      = "--autoxy" if $k eq "autoxy" and $v eq any("yes",1);
		       $logx       	      = "--logx"   if $k eq "logx" and $v eq any("yes",1);
		       $logy       	      = "--logy  " if $k eq "logy" and $v eq any("yes",1);
		       $stelar-hdf5           = "--stelar-hdf5  " if $k eq "stelar-hdf5" and $v eq any("yes",1);
		       $stelar-hdf5-Re        = "--stelar-hdf5-Re  " if $k eq "stelar-hdf5-Re" and $v eq any("yes",1);
		       $stelar-hdf5-Im        = "--stelar-hdf5-Im  " if $k eq "stelar-hdf5-Im" and $v eq any("yes",1);
		       $stelar-hdf5-R1        = "--stelar-hdf5-R1  " if $k eq "stelar-hdf5-R1" and $v eq any("yes",1);
		       $stelar-hdf5-R1        = "--stelar-hdf5-R1-err={$v.Rat}  " if $k eq "stelar-hdf5-R1-err" and $v.^name eq "Rat";
		       if $k eq "download" {
		       	  if $v eq "zip" { $file-to-download = $zip-file }
			  elsif $v eq "json" { $file-to-download = "$folder/" ~ $filename.IO.extension('json') }
			  else { $file-to-download = "$folder/$v" }
		       }
		   }
		}
		if any($filename.IO.extension.contains("zip"),$stelar-hdf5.Bool,$stelar-hdf5-Re.Bool,$stelar-hdf5-Im.Bool,$stelar-hdf5-R1.Bool,$stelar-hdf5-R1-err.Bool) {
		   $filename.IO(:bin).spurt: $file-content			
		}
		else {		 
		    $filename.IO.spurt: $file-content.decode('UTF-8')
		}	   

		$username = @args.head ~~ /username/ ?? @args.tail !! @args.head if @args.so;
		$work-folder = "./$username" if $username.so and $username.IO.e;
		$file-to-download = "$work-folder/$file-to-download" if $file-to-download.Bool;
		$zip-file = $zip-file;
		my $txt;
		if so $function {
		   $txt = "onefite fit \"$function\" $filename $global $autox $autoy $autoxy $logx $logy $stelar-hdf5 $stelar-hdf5-Re $stelar-hdf5-Im $stelar-hdf5-R1 $stelar-hdf5-R1-err --fit-methods=\"$fit-methods\" --Num=$num --work-folder=$work-folder --SymbSize=$ssz --zip-to=$zip-file --save-to=$work-folder/$folder/$folder.json";
		   $txt ~= shell("onefite fit \"$function\" $filename $global $autox $autoy $autoxy $logx $logy $stelar-hdf5 $stelar-hdf5-Re $stelar-hdf5-Im $stelar-hdf5-R1 $stelar-hdf5-R1-err --fit-methods=\"$fit-methods\" --Num=$num --work-folder=$work-folder --SymbSize=$ssz --zip-to=$zip-file --save-to=$work-folder/$folder/$folder.json",:out).out.slurp(:close);
		}
		 else {
		    $txt = "onefite fit $filename $global $autox $autoy $autoxy $logx $logy --fit-methods=\"$fit-methods\" --Num=$num --work-folder=$work-folder --save-to=$work-folder/$folder/$folder.json";
		    $txt ~= shell("onefite fit $filename $global $autox $autoy $autoxy $logx $logy --fit-methods=\"$fit-methods\" --Num=$num --work-folder=$work-folder --save-to=$work-folder/$folder/$folder.json",:out).out.slurp(:close);
		}
		if $file-to-download.Bool { content 'application/octet-stream', $file-to-download.IO.slurp(:bin) }
		else { content 'text/plain', "File '$filename' uploaded and fitted.\n$txt\n" }
		my Bool $tmp-folder-was-created = "./$tmp-folder".IO.e;
   		shell("rm -fr ./$tmp-folder") if "./$tmp-folder".IO.e;		
 		$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) fit { $file.filename } concluded in { now - $time } s. { 'Folder:' ~ $tmp-folder ~ ' removed.' if $tmp-folder-was-created }");
		$log-fh.flush;
	    }
	 }
	 post -> 'convert' {
            request-body -> (:$file, *%rest) {
    		my $filename = $file.filename;
		my $file-content = $file.body-blob;
		$filename.IO.spurt: $file-content.decode('UTF-8');
		my $tmp-folder=10000;
		loop { $tmp-folder = 10000.rand.Int; last unless "./$tmp-folder".so.IO.e }
		my $work-folder = "./$tmp-folder";
		shell "mkdir $work-folder";
		my $file-to-download = $filename.IO.extension.Str ~~ /sav/ ?? $filename.IO.extension('json').Str !! $filename.IO.extension('sav').Str; 
		my $txt = shell("onefite convert $filename $file-to-download --work-folder=$work-folder", :out).out(:close).slurp;
#		content 'text/plain', "$txt\n";
		content 'application/octet-stream', "$file-to-download".IO.slurp(:bin);
		shell "rm -fr $work-folder";
 		$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) convert { $file.filename } concluded in { now - $time } s. { 'Folder:' ~ $work-folder ~ ' removed.' }");
		$log-fh.flush;
	     }
	}
    }
     
    say "Starting onefite web service on $ip port $port";
    my Cro::Service $service = Cro::HTTP::Server.new:
			       host => $ip,
			       port => $port,
			       :$application;
    
    $service.start;

    my $log-supply = Supply.interval(60);
    
    react {
	whenever $log-supply {
	    if $log-file.IO.s > 1024*1024 {
		my $now = DateTime.now;
		$log-fh.say("$now - onefite log rotate");
		$log-fh.flush;
		$log-file.IO.rename($log-file ~ ".0");
		try $log-fh = open($log-file, :a) or die "can't open file $!";
	    }
	}
	whenever signal(SIGINT) {
	    $service.stop;
	    $log-fh.close;
	    exit;
	}
    }
}


multi MAIN ('help',
	    Str $model,
	    Bool :q(:$quiet),
	   ){
    my @list = dir(::('OFE-PATH') ~ "/C/local");
    @list.push: dir(::('OFE-PATH') ~ "/C/core/onefit-3.1/modelos").Slip;
    @list = @list.grep(*.f).grep(/\.c/)>>.basename>>.IO>>.extension('').sort;
    my %meta-c = from-json( "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp );	
    my %info = %meta-c{ @list.grep(/$model/).Str };
    my $txt = "$model => " ~ to-json(%info, :sorted-keys);
    say $txt unless $quiet;
    $txt
}

multi MAIN ('help',
	    Str $model,
            Str $key,
	    Bool :q(:$quiet),
	   ){
    my @list = dir(::('OFE-PATH') ~ "/C/local");
    @list.push: dir(::('OFE-PATH') ~ "/C/core/onefit-3.1/modelos").Slip;
    @list = @list.grep(*.f).grep(/\.c/)>>.basename>>.IO>>.extension('').sort;
    my %meta-c = from-json( "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp );	
    my %info = %meta-c{ @list.grep(/$model/).Str };
    my $txt = %info{ $key };
    say $txt unless $quiet;
    $txt
}
 
multi MAIN ('start-engine',
	    Bool :$no-plot,
	    Bool :q(:$quiet)=False, # Don't show log messages
	    Str :$work-folder = '.'
	   ){
    my $supplier = Supplier.new;
    $supplier.Supply.tap: -> $f {
	start {
	    my $cmd = "plot";
	    $f ~~ /$<cmd>=(__fit__|__plot__|__fit\-only__)* $<file>=(\S+)/;
	    my $file = $<file>;
	    $cmd = $<cmd>.subst('__','',:g);
	    my $name = $file.subst(/\.sav|\.json/,'',:g);
	    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
	    "$work-folder/$name".IO.mkdir;
	    $f.IO.move("$work-folder/$name/$file");
	    my $engine = Engine.new.path("$work-folder/$name").read("$work-folder/$name/$file");
	    if $cmd ~~ /plot/ {
		my $time = now;
		say "start plotting $file";
		$engine.plot;
		say "finished plotting $file:", now - $time;
	    }
	    elsif $cmd ~~ /only/ {
		my $time = now;
		say "start fitting $file";
		$engine.fit(:no-plot($no-plot),:quiet($quiet)).save("$work-folder/$name/$name" ~ "-fit.json");
		say "finished fitting $file:", now - $time;
	    }
	    else {
		my $time = now;
		say "start fitting $file";
		$engine.fit(:no-plot($no-plot),:quiet($quiet)).save("$work-folder/$name/$name" ~ "-fit.json");
		say "finished fitting $file:", now - $time;
	    }
	    zip-fit($engine,$work-folder,$name);
	}
    }
    
    while True {
	my @files = dir('.').grep(*.f).grep(/\.sav|\.json/).words;
	for @files -> $file {
	    if now - $file.IO.changed > 1 { 
		$supplier.emit($file);
		sleep 1;
	    }
	    else {
		sleep 1;
	    }
	}
    }
    
}

multi MAIN  ('create',
	     Str  $function,
	     *@data-files where { @data-files.map({ .IO.e or die("$_ doesn't exist!")}) },
	     Str  :data-label(:$data-labels),
             Str  :$fit-methods = "simp scan min minos",
	     Str  :$tags,
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Bool :$global,
	     Bool :$stelar-hdf5 = False,
	     Bool :$stelar-hdf5-Re = False,
	     Bool :$stelar-hdf5-Im = False,
	     Bool :$stelar-hdf5-R1 = False,
	     Rat  :$stelar-hdf5-R1-err,
	     Str  :SymbSize(:$ssz) where { $_.Rat >= 0 }= '1.0',
	     Str  :save-to(:$to), # write fit settings to json or sav file"
	     Str  :$work-folder = '.',
             Int  :Num(:$npts) = +100
	    ){
    my $name = "ofe-tmp";
    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
    "$work-folder/$name".IO.mkdir unless "$work-folder/$name".IO.e;

    if any($stelar-hdf5-R1,$stelar-hdf5-R1-err.Bool,$stelar-hdf5,$stelar-hdf5-Re,$stelar-hdf5-Im) {
	@data-files = any($stelar-hdf5-R1,$stelar-hdf5-R1-err.Bool) ??
			 Stelar-hdf5.new.path("$work-folder").filename(@data-files[0]).R1(err => $stelar-hdf5-R1-err)
			 !!
			 Stelar-hdf5.new.path("$work-folder").filename(@data-files[0]).Mz;
    }
    
    if any($stelar-hdf5-R1,$stelar-hdf5-R1-err.Bool,$stelar-hdf5,$stelar-hdf5-Re,$stelar-hdf5-Im) {
	@data-files = any($stelar-hdf5-R1,$stelar-hdf5-R1-err.Bool) ??
			 Stelar-hdf5.new.path("$work-folder/$name").filename(@data-files[0]).R1(err => $stelar-hdf5-R1-err)
			 !!
			 Stelar-hdf5.new.path("$work-folder/$name").filename(@data-files[0]).Mz(:Re($stelar-hdf5-Re),:Im($stelar-hdf5-Im));
    }
    else {
	my @files=();
	for @data-files {
	    if $_.IO.extension.Str ~~ /zip/ {
		shell "unzip $_ -d $work-folder/$name";
		@files.push: "$work-folder/$name".IO.dir>>.Str.map({ $_.subst("$work-folder/$name/",'')  }).sort.Slip;
	    }
	    else {
		@files.push: $_;
		$_.IO.copy("$work-folder/$name/$_")
	    }
	}
	@data-files= @files;
    }

    my %e = parse-function($function.subst(/\n|\r/,'',:g), @data-files,$data-labels);
    %e<FitMethods> = $fit-methods;
    %e<FitType>="Global" if $global;
    %e<Num>=$npts;
    %e<SymbSize>=$ssz.Rat;
    my $engine = Engine.new.path("$work-folder").set(%e);
    $engine.blocks(
	:read,
	:fit,
	:export,
	:autox($autox),
	:autoy($autoy),
	:logx($loglin or $loglog),
	:logy($linlog or $loglog));
    $engine.parameters(:read).functions(:read).stp.code(:write,:compile);
    %e=$engine.h;
    %e<par-tables>:delete;
    if $to.defined { $engine.set(%e).save($to) }
    else { say to-json(%e, :sorted-keys) }
    exit;
}

multi MAIN  ('random',
	     Str  $function, 
	     *@data-files where { @data-files.map({ .IO.e or die("$_ doesn't exist!")}) },
	     Str  :data-label(:$data-labels),
	     Str  :$tags,
	     Str  :$zip-to,
	     Bool :$no-plot,
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Bool :$global,
	     Str  :$save-to, # write fit settings to json or sav file 
	     Str  :$work-folder = '.',
	     Int  :Num(:$npts) = +100
	    ){
    my %e = parse-function($function.subst(/\n|\r/,'',:g), @data-files,$data-labels);
    %e<FitType>="Global" if $global;
    %e<Num>=$npts;
    for %e.kv -> $k, $v {
	if all($k.contains("Pval"), %e{$k.subst('val','max')}.Bool, %e{$k.subst('val','min')}.Bool) {
	    $k ~~ /Pval $<i>=(\d+)/;
	    %e{$k}= (%e{$k.subst('val','min')}.Real .. %e{$k.subst('val','max')}.Real).rand;
	    %e{'F' ~ $<i>.Str}= "Fix";
	}
    }
    my $name = "ofe-tmp";
    if $zip-to.Bool {
	$name = $zip-to.subst(/\.zip/,'',:g);
    }
    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
    "$work-folder/$name".IO.mkdir;
    for @data-files { $_.IO.copy("$work-folder/$name/$_") };
    my $engine = Engine.new.path("$work-folder/$name").set(%e);
    $engine.fit(
	:no-plot($no-plot),
	:autox($autox or $autoxy),
	:autoy($autoy or $autoxy),
	:logx($loglin or $loglog),
	:logy($linlog or $loglog)
    );
    $engine.save($save-to) if $save-to.defined;
    zip-fit($engine,$work-folder,$name) if $zip-to.Bool;
#    shell "pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
    exit;
}

multi MAIN  ('fit',
	     Str  $function is copy, 
	     *@data-files where { @data-files.map({ .IO.e or die("$_ doesn't exist!")}) },
	     Str  :data-label(:$data-labels),
             Str  :$fit-methods = "simp scan min minos",
	     Str  :$tags,
	     Str  :$zip-to,
	     Bool :$no-plot,
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Bool :$global,
	     Bool :$stelar-hdf5 = False,
	     Bool :$stelar-hdf5-Re = False,
	     Bool :$stelar-hdf5-Im = False,
	     Bool :$stelar-hdf5-R1 = False,
	     Rat  :$stelar-hdf5-R1-err,
	     Str  :SymbSize(:$ssz) where { $_.Rat >= 0 }= '1.0',
	     Str  :$save-to, # write fit settings to json or sav file 
	     Str  :$work-folder = '.',
	     Int  :Num(:$npts) = +100
	    ){
    my $name = "ofe-tmp";
    if $zip-to.Bool {
	$name = $zip-to.subst(/\.zip/,'',:g);
    }
    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
    "$work-folder/$name".IO.mkdir unless "$work-folder/$name".IO.e;
    
    if any($stelar-hdf5-R1,$stelar-hdf5-R1-err.Bool,$stelar-hdf5,$stelar-hdf5-Re,$stelar-hdf5-Im) {
	@data-files = any($stelar-hdf5-R1,$stelar-hdf5-R1-err.Bool) ??
			 Stelar-hdf5.new.path("$work-folder/$name").filename(@data-files[0]).R1(err => $stelar-hdf5-R1-err)
			 !!
			 Stelar-hdf5.new.path("$work-folder/$name").filename(@data-files[0]).Mz(:Re($stelar-hdf5-Re),:Im($stelar-hdf5-Im));
    }
    else {
	my @files=();
	for @data-files {
	    if $_.IO.extension.Str ~~ /zip/ {
		shell "unzip $_ -d $work-folder/$name";
		@files.push: "$work-folder/$name".IO.dir>>.Str.map({ $_.subst("$work-folder/$name/",'')  }).sort.Slip;
	    }
	    else {
		if $_.IO.slurp.contains(/'#' <ws> DATA <ws>/) {
			my @blocks = $_.IO.slurp.split(/'#' <ws> DATA <ws>/);
			for (1 ..^ @blocks.elems) -> $i {
				my $file-name="{$_.IO.extension('').Str}-block{$i}.dat";
				$file-name = $_ unless @blocks.elems > 2;
				@files.push: $file-name; 
				"$work-folder/$name/$file-name".IO.spurt: "# DATA { @blocks[$i] }";
			}	 
		}
		else {	
		    @files.push: $_;
		    $_.IO.copy("$work-folder/$name/$_")
		}
	    }
	}
	@data-files= @files;
    }
    my %alias = from-json( "{ ::('OFE-PATH') }/../etc/alias.json".IO.slurp ) if  "{ ::('OFE-PATH') }/../etc/alias.json".IO.e;
    if $function.contains(/^a\w*  <ws> ':' <ws>/) { 
	my $falias = %alias{ $function.subst(/a\w*\s*':'\s*/,'').subst(/\s+/,' ') };
	if so $falias { $function = $falias }
	else { say "function alias not found in { ::('OFE-PATH') }/../etc/alias.json"; say %alias.keys;  }
    }
    my %e = parse-function($function.subst(/\n|\r/,'',:g), @data-files,$data-labels, path => "$work-folder/$name");
    %e<FitMethods> = $fit-methods;
    %e<FitType>="Global" if $global;
    %e<Num>=$npts;
    %e<SymbSize>=$ssz.Rat;
    my $engine = Engine.new.path("$work-folder/$name").set(%e);
    $engine.fit(
	:no-plot($no-plot),
	:autox($autox or $autoxy),
	:autoy($autoy or $autoxy),
	:logx($loglin or $loglog),
	:logy($linlog or $loglog)
    );
    $engine.save($save-to) if $save-to.defined;
    zip-fit($engine,$work-folder,$name) if $zip-to.Bool;

    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";

    exit;
}

multi MAIN  ('fit',
	     Str  $input-file where { $input-file.IO.e or die "$input-file dosen't exist!" }, #= name of the (.sav or .json) to compile
             Str  :$fit-methods = "simp scan min minos",
	     Bool :$no-plot,
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Str  :save-to(:$to), # write fit settings to json or sav file 	     
	     Str  :$zip-to = $input-file.IO.extension('').Str,
	     Str  :$work-folder = '.',
	     Int  :Num(:$npts)
	    ){
	    my $name = $input-file.subst(/\.sav|\.json/,'',:g);
	    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
	    "$work-folder/$name".IO.mkdir;
	    $input-file.IO.copy("$work-folder/$name/$input-file");
	    my $engine = Engine.new.path("$work-folder/$name").read("$work-folder/$name/$input-file");
#	    my $engine = OFE::Engine.new.path("$work-folder").read($input-file);
	    $engine.Num($npts) if $npts.Bool;
	    $engine.fit-methods($fit-methods);
	    $engine.fit(
		:no-plot($no-plot),
		:autox($autox or $autoxy),
		:autoy($autoy or $autoxy),
		:logx($loglin or $loglog),
		:logy($linlog or $loglog)
	    );
	    $engine.save($to) if $to.defined;
	    zip-fit($engine,$work-folder,$name);
	    shell "mv $name.zip $zip-to" unless $name eq $zip-to;
	    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
	    exit;
}


multi MAIN  ('plot',
	     Str $input-file where { $input-file.IO.e or die "$input-file dosen't exist!" }, #= name of the (.sav or .json) to compile
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Str  :$work-folder = '.',
	     Int  :Num(:$npts)
	    ){
	    my $name = $input-file.subst(/\.sav|\.json/,'',:g);
	    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
	    "$work-folder/$name".IO.mkdir;
	    $input-file.IO.copy("$work-folder/$name/$input-file");
	    my $engine = Engine.new.path("$work-folder/$name").read("$work-folder/$name/$input-file");
	    #	    my $engine = Engine.new.path("$work-folder").read($input-file);
	    $engine.Num($npts) if $npts.Bool;
	    $engine.plot(
		:autox($autox or $autoxy),
		:autoy($autoy or $autoxy)
		:logx($loglin or $loglog),
		:logy($linlog or $loglog)
	    );
	    zip-fit($engine,$work-folder,$name);
	    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
	    exit;
}


multi MAIN ('test','list') {
    my $test-path=OFE-PATH ~ "/t";
#    my $test-path=OFE-PATH.subst("rakumod/OFE","t");
    dir($test-path).grep(*.f).grep(/rakutest/).map( { .subst("$test-path/","",:g).say });
}	    

multi MAIN ('test',
	    *@arr,
	    Bool :verbose(:$v) = False
	   ){
    my $test-path=OFE-PATH ~ "/t";
#    my $test-path=OFE-PATH.subst("rakumod/OFE","t");

    "/tmp/OneFit-Engine-test".IO.mkdir unless "/tmp/OneFit-Engine-test".IO.d(:e);
    
    if @arr.elems > 0 {
	my $fho = open :w, 'tests.log';
	@arr.race.map(
	    {
		my $test = "$_.rakutest" unless .contains(/rakutest/);
		say "testing....$test"; run "raku", "$test-path/$test" , :err<fho>
	    }
	);
	$fho.close;
	"tests.log".IO.slurp.say;
    }
    else {
	my $proc = run "prove6", "--lib", "$test-path","--err=ignore";
    }
    run-post-install-tests(:verbose($v));
    exit;
}

sub parse-function ($function, @data-files, $data-labels, Str :$path = ".") {
    my %e = OneFit::Engine::Grammars::Function.parse-me($function);
    %e<FitType T Num> = <Individual dum 100>;
    %e<SelectedDataSet> = @data-files[0].subst(".dat","");
    for (1 .. @data-files.elems) {
	my @lines="$path/{@data-files[$_-1]}".IO.lines;
	my $label = "dum";
	my $dum=$_;
	$dum = @lines.head if @lines.head.words.elems < 2;
	if @lines.grep(/DATA/) {
	    $label = @lines.grep(/DATA/).split("=")[0].split("DATA")[1].words[0];
	    $dum = @lines.grep(/DATA/).split("=")[1];
	    %e<T> = $label;
	    shift @lines;
	}
	if @lines.grep(/TAG/) {
	    shift @lines;
	}
	if $data-labels.defined {
	    my $dum-parse = OneFit::Engine::Grammars::Label.parse($data-labels);
	    $label = $dum-parse<name>.Str;
	    %e<T> = $label;
	    if $dum-parse<values> > 0 { $dum = $dum-parse<values>[$_-1].Str.join(' ') }
	}
	%e<Dados> ~= "\n# DATA $label = $dum\n";
	%e<Dados> ~= "# TAG = { @data-files[$_-1].subst(".dat","") }\n";
	%e<Dados> ~= @lines.join("\n") ~ "\n\n";
	%e<Tags>.push: @data-files[$_-1].subst(".dat","");
    }
    return %e;
}

sub zip-fit ($engine,$work-folder,$name) {
    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
    my $excluded =  { "$work-folder/$name/" <<~<< <AuxCode.* onefit-user *.h *.c *.o *_ gnu* *.stp> }().join(' ') ;
    "$name.zip".IO(:e).unlink;
    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
    shell "zip -q -r $work-folder/$name.zip $work-folder/$name -x $excluded";
}

sub run-post-install-tests(Bool :$verbose = False) {
    my $data = q:to/EOT/;
# DATA dum = 40616
# TAG = zone12
# R1 = 16.9554
2.4 0.4950845801988824 1
1.60968 0.5030929382053178 1
1.07962 0.5071383400239955 1
0.724101 0.5192948321930172 1
0.485656 0.5160022771910805 1
0.32573 0.5291235757829099 1
0.218468 0.5350239458592603 1
0.146527 0.5898993575693909 1
0.098276 0.6180204586347606 1
0.065914 0.6826722682863811 1
0.044208 0.752954560068173 1
0.029651 0.8279391722256552 1
0.019887 0.8918345724621874 1
0.013338 0.9470250641189731 1
0.008946 0.9713798167045512 1
0.006 1.0 1.0 
EOT


        say "Running post-install tests...\n";
        "/tmp/zone12.dat".IO.spurt: $data;
	my $service = shell("systemctl status onefite",:out).out.slurp(:close).contains("active (running)");
	if $service {
	    put "testing localhost onefite web service... ";
	    my $result = "curl --silent -F \"file=\@zone12.dat\" -F \"stelar-hdf5=no\" -F \"autox=yes\" -F \"logx=yes\" -F \"function=Mz[-2<2](t,M0,Mi,T1[0.01<3])=Mi \+ (M0-Mi)*exp(-t/T1)\" http://127.0.0.1:8142/fit --output ofe-test.log";
	    say $result if verbose;
	    $result = shell("cd /tmp && $result");
	    $result = "/tmp/ofe-test.log".IO.slurp(:close);
	    say $result if $verbose;
	    if $result.contains("zone12, 16") {
		put "OK\n";
	    }
	    else {
		put "error!\n";
	    }
	}
	else {
	    say "onefite service if off in all ports";
	}
	my &fileowner = { my $file = $^a; shell("ls { $file.IO.d ?? '-ld' !! '-la'} $file | awk '\{print \$3\}'",:out).out.slurp(:close) };
	</tmp/ofe-tmp>.map({ $_.IO.e and fileowner($_).contains("root") ?? shell("sudo rm -fr $_") !! shell("rm -fr $_") });

	put "testing command line onefite...";
	my $result = shell("cd /tmp/ && onefite fit \"Mz[-2<2](t,M0,Mi,T1[0.01<3])=Mi \+ (M0-Mi)*exp(-t/T1)\" zone12.dat --no-stelar-hdf5 --autox --logx", :out).out.slurp(:close);
	say $result if $verbose;
	if $result.contains("zone12, 16") {
	    put "OK\n";
	}
	else {
	    put "error!\n\n";
	}
#	$SUDO = "sudo" if any( (fileowner("/tmp/ofe-tmp"), fileowner("/tmp/ofe-test.log"), fileowner("/tmp/OneFit-Engine-test"), fileowner("/tmp/zone12.dat"))>>.contains("root"));
#	shell "$SUDO rm -fr /tmp/ofe-tmp /tmp/OneFit-Engine-test /tmp/zone12.dat /tmp/ofe-test.log " if "/tmp/zone12.dat".IO.e;
	</tmp/ofe-tmp /tmp/OneFit-Engine-test /tmp/zone12.dat /tmp/ofe-test.log>.map({ $_.IO.e and fileowner($_).contains("root") ?? shell("sudo rm -fr $_") !! shell("rm -fr $_") });
}

