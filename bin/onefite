#!/usr//bin/env raku

my $time = BEGIN { now }
END { note "Total execution time (s): " , now - INIT now }

note "Compile time: ", now - $time;

our constant OFE-PATH="%OFE-PATH%";

use OneFit;
use OneFit::Engine::Grammars;
use OneFit::Engine::Parameters;
use OneFit::Engine::Parfiles;
use OneFit::Engine::Stpfiles;
use OneFit::Engine::Import;
use Pod::To::Text;
use Pod::To::Man;
use Test;

use Cro::HTTP::Router;
use Cro::HTTP::Server;
use Cro::HTTP::Log::File;
use JSON::Fast;

my %*SUB-MAIN-OPTS =  :named-anywhere, :allow-no, :bundling ;

proto MAIN(|) { * };

#| Get onefite man page
multi MAIN (Bool :$man!) {
	my $txt = pod2text $=pod;
	$txt = $txt ~ "\n\n\n" ~ MAIN(:v);
	say $txt;
	$txt
}

#| Get onefite man page
multi MAIN('man') { MAIN(:man) }

#| Get onefite usage help
multi MAIN (
	Bool :h(:help($help)) #= help option true by default 
) {
	say $*USAGE;   
	note qq:to/END_USAGE/;
    <input-file>     name of the file to be converted (\.sav or \.json)
    <output-file>    name of the converted file (\.sav or \.json)
    fit-methods: simp scan min minos

    <function> syntax alternatives:
    /\"y(x,a,b,c)=a + b*x + c*pow(x,2.0)\"
    \"y(t,A,lambda: 0.1)=A*exp(-lambda*t)\" 0.1 is the initial value to start mimimization
    \"y (t,A,B=2,lambda)=A * (1 - B*exp(-lambda*t) )\" B is fixed with value 2
    \"y( t,A, lambda: [0;0.5])=A*exp(-lambda*t)\" [lambda is limited to range 0 to 0.
    \"R1(f:[0;1e9], A, tau[0<1e-9])=A*tau/(1+pow(2*pi*f*tau,2.0)\" f is limite to positive values up to 1e9 and tau also
    \"y[-1;1](x:[0<1],a,b,c)=a + b*x + c*x*x\" theoretical curves generated for x is limited to range 0 to 1; in the plot y axis will be limited to range -1 to 1
    \"f(x,p1: 2, p2=0.3, p3[5<10]) :[-5;5]=p1*exp(-p2*x)*sin(2*pi*x/p3)\" p1 is initialized to 1, p2 is fixed to 2 p3 will be in the range 5 to 10
END_USAGE
}

#| Get onefite library models and aliases lists
multi MAIN ('list',
      	   Bool :q(:$quiet) = False #= reduces output log info, false by default
	   ){
#    my @list = dir(::('OFE-PATH') ~ "/C/local");
#    @list.push: dir(::('OFE-PATH') ~ "/C/core/onefit-3.1/modelos").Slip;
#    @list = @list.grep(*.f).grep(/\.c/)>>.basename>>.IO>>.extension('').sort;
#    my $txt = "OneFit Engine Models Library:\n";
#    $txt ~= @list.join("\n");
     my $txt = MAIN('list', 'models', quiet => True);
     #my $txt = "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp;
    $txt ~= MAIN('list', 'aliases', quiet => True); 
    #$txt ~=  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.slurp  if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
    say $txt unless $quiet;
    $txt;
}

#| Get onefite library models list
multi MAIN ('list','models',
      	   Bool :q(:$quiet) = False
	   ){
     my $txt = "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp;
     say $txt unless $quiet;
     $txt;
}

#| Get onefite library models aliases list
multi MAIN ('list','aliases',
      	   Bool :q(:$quiet) = False
	   ){
	my %aliases = from-json( "{ ::('OFE-PATH') }/../etc/aliases.json".IO.slurp ) if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
	%aliases = %aliases.Slip, from-json("{$*CWD}/aliases.json".IO.slurp).Hash.Slip  if "{$*CWD}/aliases.json".IO.e; 
 	
	#	my $txt = "{ ::('OFE-PATH') }/../etc/aliases.json".IO.slurp  if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
	my $txt = to-json(%aliases);
	if not $quiet {
           say "listing aliases @  { ::('OFE-PATH') }/../etc/aliases.json"  if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
           say "listing aliases @ ./aliases.json"  if  "./aliases.json".IO.e;
	   say $txt;
	}
	$txt;
}

#| onefite convert sav <-> json files 
multi MAIN ('convert',
	    Str $input-file where { $input-file.IO.e or die "$input-file dosen't exist!" }, #= name of the file to be converted (sav or json)
	    Str $output-file, #= name of the converted file (sav or json)
            Str :$work-folder = "." #= work folder for onefite convert
	   ) {
    my $eng = Engine.new.path($work-folder).read($input-file).blocks(:r).parameters(:r).functions(:r).code(:write,:compile).save($output-file);
    return 0;
}

#|( Get onefite paths to src, etc)
multi MAIN ('path',
      Bool :s(:$src) = False, #= path to src
      Bool :$t = False, #= path to test
      Bool :e(:$examples) = False, #= path to examples
      Bool :b(:$bin) = False, #= path to bin
      Bool :l(:$lib) = False, #= path to lib
      Bool :c(:$C) = False, #= path to C code
      Bool :$log = False, #= path to log
	  Bool :a(:$aliases) = False # path to aliases
      ){
      if none($src,$t,$bin,$lib,$C,$examples,$aliases) {
      	 say ::('OFE-PATH');
		 say ::('OFE-PATH') ~ "/t";
		 say ::('OFE-PATH') ~ "/examples";
		 say ::('OFE-PATH') ~ "/lib";
		 say ::('OFE-PATH') ~ "/bin";
		 say ::('OFE-PATH') ~ "/../bin";
		 say ::('OFE-PATH') ~ "/../log";
	 	 say ::('OFE-PATH') ~ "/C";
	 	 say ::('OFE-PATH') ~ "/../etc";
      }
      else {
      	 say ::('OFE-PATH') if $src;
		 say ::('OFE-PATH') ~ "/t" if $t;
		 say ::('OFE-PATH') ~ "/examples" if $examples;
		 say ::('OFE-PATH') ~ "/lib" if $lib;
		 say ::('OFE-PATH') ~ "/../bin" if $bin;
		 say ::('OFE-PATH') ~ "/../log" if $log;
		 say ::('OFE-PATH') ~ "/C" if $C;
		 say ::('OFE-PATH') ~ "/../etc" if $aliases;
      }
}

#|(onefite upgrade)
multi MAIN ('upgrade',
      Bool :u(:$to-user) = False, #= install to user
      Bool :c(:$compile) = True, #= compile before install
      Bool :d(:$systemd-daemon) = False, #= create a sysmtemd-daemon service
      Bool :$cernlib = False, #= install cern lib instead of just minuit.a from src
      Bool :$shell = False, #= install shellinabox
      Int  :$shell-port = 8100, #= shellinabox port
      Str  :$ip = '*', #= set IP
	  Bool :$wsl = False, #= subset of options for a Windows Subsystem Linux
	  Bool :$macos = False, #= subset of options for a MacOS native install with brew 
	  Bool :$docker = False, #= subset of options for a MacOS colima/docker install
      Int  :p(:$port) = 8142, #= onefite service port
      Bool :$test = False, #= perform tests
	  Bool :apt(:apt-get(:$dpkg)) = True, #= run apt update/upgrade
      Str  :m(:merge-from(:merge-with(:$merge-site))) = '', #= merge remote onefite main/dev branches with locl branch
      ){
      shell "sudo service onefite stop" if $systemd-daemon and !$to-user and shell("sudo systemctl list-units | awk \'/^onefite/ \{print \$1\}\'",:out).out.slurp.Bool;
      
      shell "cd { ::('OFE-PATH') }  && git stash && git pull && ./INSTALL { ($to-user) ?? '--to-user' !! '' } { '-/c' unless $compile } { '-d' if $systemd-daemon } { $test ?? '--test' !! '--/test' } --ip=$ip --port=$port { ($merge-site.Bool) ?? '-m=' ~ $merge-site !! '' } { '--cernlib' if $cernlib } { '--shell --shell-port=' ~ $shell-port if $shell } { '--wsl' if $wsl } { '--macos' if $macos } { '--docker' if $docker } { '--no-dpkg' unless $dpkg}";
      MAIN('service','start',:systemd-daemon(all($systemd-daemon,!$to-user)),ip => $ip, port => $port)
}

#|(onefite uninstall)
multi MAIN ('uninstall'){
      MAIN('stop-web-engine');
      shell "cd { ::('OFE-PATH') } && git stash && git pull && ./INSTALL -U";
      exit;  
}

#|(onefite web service start)
multi MAIN ('service','start',	
      Bool :d(:$systemd-daemon) = False, #= start systemd-daemon
      Str  :$ip = '*', #= accept access form IP
      Int  :p(:$port) = 8142, #= onefite werbservice port
      ) {
      if $systemd-daemon {
           say "stoping onefite service...";
      	   my $proc = shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1];
      	   shell "sudo kill -9 $proc" if so $proc;
           shell 'sudo systemctl daemon-reload';
	   shell 'sudo systemctl enable onefite.service';
	   shell 'sudo service onefite start';
	   say "service onefite started on IPv4 $ip and port $port";
      }
      else {           
            say "stoping onefite service...";
      	    my $proc = shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1];
      	    shell "kill -9 $proc" if so $proc;
      	    say "starting onefite service on $*HOME/public_html and go in the backgound";
      	    shell "cd $*HOME/public_html; nohup onefite start-web-engine --ip=$ip --port=$port &";
      }
      exit
}

#|(onefite web service stop)
multi MAIN ('service','stop') { MAIN('stop-web-engine'); exit }

#|(onefite web service log)
multi MAIN ('service','log') { "{ ::('OFE-PATH') }/../log/onefite".IO.slurp.say; exit }

#|(get onefite service PID)
multi MAIN ('service','PID') { shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1].say; exit }

#|(onefite web service stop by removing service process)
multi MAIN ('stop-web-engine'){
      my $proc = shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1];
      shell "kill -9 $proc" if so $proc;
}

#|(onefite web engine)
multi MAIN ('start-web-engine',
	    Str :$ip is copy, #= accept connections from IP
		Num :p(:$port) = +8142, #= onefite web service port
	   ){
	my $ip-proc = shell("ip -4 -br -j add",:out);
	$ip = !$ip-proc.exitcode ?? from-json($ip-proc.out.slurp(:close)).tail<addr_info>.head<local> !! "127.0.0.1"; 
	my $log-file="{ ::('OFE-PATH') }/../log/onefite";
    my $log-fh = open($log-file, :a);
    my $application = route {
	   get -> {
	     $log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) get webform");
	     $log-fh.flush;

	       content 'text/html', q:to/HTML/;
               	<!DOCTYPE html>
            	<html>
           	 <head>
            	   <title>OneFit Engine Web Server</title>
            	 </head>
            	  <body>
            	     <h1>OneFit Engine Web Server</h1>

            	     <form action="/fit" method="post" enctype="multipart/form-data">
            	     Upload file [.json | .sav | .hdf5 | data-file ] <input type="file" name="file"><br/>
		       Download: <input type="text" name="download" value="zip"><br/>
		       Username: <input type="text" name="username" value="<username>"><br/>
		       Num points: <input type="text" name="Num" value="100"><br/>
		       Symbol size: <input type="text" name="SymbSize" value="1.0"><br/>
		       Fit methods: <input type="text" name="fit-methods" value="simp scan min minos"><br/>
		       Data file fitting function: <textarea rows="1" cols="100" name="function" value=""></textarea>
		       <table>
		       <tr><td></td><td>yes/no</td></tr>
		       <tr><td>global fit: </td><td><input name="global" type="radio" value="yes">/<input name="global" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>autox: </td><td><input name="autox" type="radio" value="yes">/<input name="autox" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>autoy: </td><td><input name="autoy" type="radio" value="yes">/<input name="autoy" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>autoxy: </td><td><input name="autoxy" type="radio" value="yes">/<input name="autoxy" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>logx: </td><td><input name="logx" type="radio" value="yes">/<input name="logx" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>logy: </td><td><input name="logy" type="radio" value="yes">/<input name="logy" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>ist-ffc: </td><td><input name="ist-ffc" type="radio" value="yes">/<input name="ist-ffc" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>R1: </td><td><input name="R1" type="radio" value="yes">/<input name="R1" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>err: </td><td><input name="err" type="text" value="">(number, num%, num%avg, num% avg split xvalue, stdv, stdv split xvalue; ex. 1.0, 10%, 10%avg, 1% avg split at 2e4, stdv, "stdv split at 2e4")</td></tr>
		       <tr><td>range: </td><td><input name="range" type="text" value="">(window range: i:f)</td></tr>
		       <tr><td>plot-if: </td><td><input name="plot-if" type="text" value="">(ex: c1>0.5,1)</td></tr>
		       <tr><td>fit-if: </td><td><input name="fit-if" type="text" value="">(ex: c1<2,10)</td></tr>
		       <tr><td>gfilt: </td><td><input name="gfilt" type="text" value="">(int number)</td></tr>
		       <tr><td>sef-R1-file: </td><td><input name="sef-R1-file" type="text" value=""></td></tr>
		       </table>
           	       <button type="submit">fit</button>
            	     </form>
            	     <form action="/convert" method="post" enctype="multipart/form-data">
           	       <button type="submit">convert</button>
            	     </form>
            	     <form action="/list" method="post" enctype="multipart/form-data">
           	       <button type="submit">list models</button>
            	     </form>
            	     <form action="/help" method="post" enctype="multipart/form-data">
           	       <button type="submit">help</button>
		       model: <input name="model" type="text" value="BPP" size=20>
		       key: <input name="key" type="text" values="" size=20>
            	     </form>
            	     <form action="/man" method="post" enctype="multipart/form-data">
           	       <button type="submit">man page</button>
            	     </form>
 
            	  </body>
            	 </html>
HTML
	}
	get -> 'list',*@args {
	     $log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) list");
	     $log-fh.flush;
	     if @args.so { content 'text/plain', "{ MAIN('list',@args.head,:quiet) }\n" }
	     else { content 'text/plain', "{ MAIN('list',:quiet) }\n" }	
	}	
	
	post -> 'list',*@args {
	     $log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) list");
	     $log-fh.flush;
	     if @args.so { content 'text/plain', "{ MAIN('list',@args.head,:quiet) }\n" }
	     else { content 'text/plain', "{ MAIN('list',:quiet) }\n" }	
	}
	
	get -> 'help',*@args {
	     $log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) help");
	     $log-fh.flush;
	     if so @args {
		  	if @args.elems > 1 { content 'text/plain', "{ MAIN('help',@args.head, @args.tail, :quiet) }\n" }
		  	else { content 'text/plain', "{ MAIN('help',@args.head,:quiet) }\n" }
	     }
	     else { 	content 'text/plain', "type model name or model name and key to get help\n" }
	}	
	
	post -> 'help' {
            request-body -> (:$model, *%rest) {
	    	$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) help");
			$log-fh.flush;
	    	if so %rest.kv {
		   		for %rest.kv -> $k,$v {
		       		if so $v.Str { content 'text/plain', "{ MAIN('help',$model.Str, $v.Str, :quiet) }\n" }
		       		else { content 'text/plain', "{ MAIN('help',$model.Str,:quiet) }\n" }
		   		}
	    	}
		    else { 	content 'text/plain', "{ MAIN('help',$model.Str,:quiet) }\n" }
	    }
	}
		
	get -> 'man',*@args {
	    	$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) help");
			$log-fh.flush;
		   	content 'text/plain', "{ MAIN( man => True ) }\n" 
	}
	

	post -> 'man' {
	    	$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) help");
			$log-fh.flush;
		   	content 'text/plain', "{ MAIN( man => True ) }\n" 
	}
	
	post -> 'fit',*@args {
            request-body -> (:$file,*%rest) {
	        my $username = "";
	        my $time = now;
    		my $filename = $file.filename;
		my $folder = $filename.IO.extension('').Str;
		my $zip-file = $filename.IO.extension('zip').Str;		
		my $file-to-download = ""; 
		my $function = "";
		my $autox = "";
		my $autoy = "";
		my $autoxy= "";
		my $logx= "";
		my $logy= "";
		my $global="";
		my $R1 = "";
		my $err = "";
		my $fit-if = "";
		my $plot-if = "";
		my $gfilt = "";
		my $range = "";
		my $sef-R1-file = "";
		my $num   = "--Num=100";
		my $ssz   = "--SymbSize=1.0";
		my $fit-methods = "--fit-methods=\"simp scan min minos\"";
		my $file-content = $file.body-blob;
		my $tmp-folder=10000;
		loop { $tmp-folder = 10000.rand.Int; last unless "./$tmp-folder".so.IO.e }
		my $work-folder = "./$tmp-folder";
#		$filename.IO.spurt: $file-content.decode('UTF-8');
		if so %rest.kv {
		   for %rest.kv -> $k, $v {
		       $fit-methods	      = "--fit-methods=\"{$v.Str}\" " if $k eq "fit-methods";
		       $function      	      = "\"{$v.Str}\""     if $k.contains("function");
		       $num        	      = "--Num={+$v.Str} " if $k eq "Num";
		       $ssz		      = "--SymbSize={$v.Str} " if $k eq "SymbSize";
		       $username   	      = $v.Str     if $k eq "username";
		       $global      	      = "--global" if $k eq "global"  and $v eq any("yes",1);
		       $autox      	      = "--autox"  if $k eq "autox"  and $v eq any("yes",1);
		       $autoy      	      = "--autoy"  if $k eq "autoy"  and $v eq any("yes",1);
		       $autoxy     	      = "--autoxy" if $k eq "autoxy" and $v eq any("yes",1);
		       $logx       	      = "--logx"   if $k eq "logx" and $v eq any("yes",1);
		       $logy       	      = "--logy  " if $k eq "logy" and $v eq any("yes",1);
		       $R1  		         = "--R1  " if $k eq "R1" and $v eq any("yes",1);
		       $sef-R1-file        = "--sef-R1-file={$v.Str}  " if $k eq "sef-R1-file" and $v.so;
		       $err                = "--err={$v.Str}  " if $k eq "err" and $v.so;
		       $range                = "--range={$v.Str}  " if $k eq "range" and $v.so;
		       $fit-if   			= "--fit-if={$v.Str}  " if $k eq "fit-if" and $v.so;
		       $plot-if   			= "--plot-if={$v.Str}  " if $k eq "plot-if" and $v.so;
		       $gfilt   			= "--gfilt={$v.Str}  " if $k eq "gfilt" and $v.so;
			



		       if $k eq "download" {
		       	  if $v eq "zip" { $file-to-download = $zip-file }
			  elsif $v eq "json" { $file-to-download = "$folder/" ~ $filename.IO.extension('json') }
			  else { $file-to-download = "$folder/$v" }
		       }
		   }
		}
		if any($filename.IO.extension.contains("zip"),$filename.IO.extension.contains("hdf5")) {
		   $filename.IO(:bin).spurt: $file-content			
		}
		else {		 
		    $filename.IO.spurt: $file-content.decode('UTF-8')
		}	   
		$username = @args.head ~~ /username/ ?? @args.tail !! @args.head if @args.so;
		$work-folder = "./$username" if $username.so and $username.IO.e;
		$file-to-download = "$work-folder/$file-to-download" if $file-to-download.Bool;
		$zip-file = $zip-file;
		my $txt;
		if so $function {
		   $txt = "onefite fit $function $filename $global $autox $autoy $autoxy $logx $logy $R1 $sef-R1-file $err $plot-if $fit-if $range $gfilt $fit-methods $num $ssz --work-folder=$work-folder --zip-to=$zip-file --save-to=$work-folder/$folder/$folder.json".subst(/\s+/," ",:g);
		   $txt ~= shell($txt,:out).out.slurp(:close);
		}
		 else {
		    $txt = "onefite fit $filename $global $autox $autoy $autoxy $logx $logy $fit-methods $num --work-folder=$work-folder --save-to=$work-folder/$folder/$folder.json".subst(/\s+/," ",:g);
		    $txt ~= shell($txt,:out).out.slurp(:close);
		}
		if $file-to-download.Bool { content 'application/octet-stream', $file-to-download.IO.slurp(:bin) }
		else { content 'text/plain', "File '$filename' uploaded and fitted.\n$txt\n" }
		my Bool $tmp-folder-was-created = "./$tmp-folder".IO.e;
   		shell("rm -fr ./$tmp-folder") if "./$tmp-folder".IO.e;		
 		$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) fit { $file.filename } concluded in { now - $time } s. { 'Folder:' ~ $tmp-folder ~ ' removed.' if $tmp-folder-was-created }");
		$log-fh.flush;
	    }
	 }
	 post -> 'convert' {
            request-body -> (:$file, *%rest) {
    		my $filename = $file.filename;
		my $file-content = $file.body-blob;
		$filename.IO.spurt: $file-content.decode('UTF-8');
		my $tmp-folder=10000;
		loop { $tmp-folder = 10000.rand.Int; last unless "./$tmp-folder".so.IO.e }
		my $work-folder = "./$tmp-folder";
		shell "mkdir $work-folder";
		my $file-to-download = $filename.IO.extension.Str ~~ /sav/ ?? $filename.IO.extension('json').Str !! $filename.IO.extension('sav').Str; 
		my $txt = shell("onefite convert $filename $file-to-download --work-folder=$work-folder", :out).out(:close).slurp;
#		content 'text/plain', "$txt\n";
		content 'application/octet-stream', "$file-to-download".IO.slurp(:bin);
		shell "rm -fr $work-folder";
 		$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) convert { $file.filename } concluded in { now - $time } s. { 'Folder:' ~ $work-folder ~ ' removed.' }");
		$log-fh.flush;
	     }
	}
    }
     
    say "Starting onefite web service on $ip port $port";
    my Cro::Service $service = Cro::HTTP::Server.new:
			       host => $ip,
			       port => $port,
			       :$application;
    
    $service.start;

    my $log-supply = Supply.interval(60);
    
    react {
	whenever $log-supply {
	    if $log-file.IO.s > 1024*1024 {
		my $now = DateTime.now;
		$log-fh.say("$now - onefite log rotate");
		$log-fh.flush;
		$log-file.IO.rename($log-file ~ ".0");
		try $log-fh = open($log-file, :a) or die "can't open file $!";
	    }
	}
	whenever signal(SIGINT) {
	    $service.stop;
	    $log-fh.close;
	    exit;
	}
    }
}

#|(onefite help on models)
multi MAIN ('help',
	    Str $model, #= model name
	    Bool :q(:$quiet), #= quiet for reduced log info
	   ){
    my @list = dir(::('OFE-PATH') ~ "/C/local");
    @list.push: dir(::('OFE-PATH') ~ "/C/core/onefit-3.1/modelos").Slip;
    @list = @list.grep(*.f).grep(/\.c/)>>.basename>>.IO>>.extension('').sort;
    my %meta-c = from-json( "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp );	
    my %info = %meta-c{ @list.grep(/$model/).Str };
    my $txt = "$model => " ~ to-json(%info, :sorted-keys);
    say $txt unless $quiet;
    $txt
}

#|(onefite help on model and keys)
multi MAIN ('help',
	    Str $model, #= model name
            Str $key, #= model key info
	    Bool :q(:$quiet), #= quite for reduced log info
	   ){
    my @list = dir(::('OFE-PATH') ~ "/C/local");
    @list.push: dir(::('OFE-PATH') ~ "/C/core/onefit-3.1/modelos").Slip;
    @list = @list.grep(*.f).grep(/\.c/)>>.basename>>.IO>>.extension('').sort;
    my %meta-c = from-json( "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp );	
    my %info = %meta-c{ @list.grep(/$model/).Str };
    my $txt = %info{ $key };
    say $txt unless $quiet;
    $txt
}
 
#!(onefite non-web engine service)
multi MAIN ('start-engine',
	    Bool :$no-plot, #= no plot
	    Bool :q(:$quiet)=False, #= Don't show log messages
	    Str :$work-folder = '.', #= onefite engine work folder
	   ){
    my $supplier = Supplier.new;
    $supplier.Supply.tap: -> $f {
		start {
	    	my $cmd = "plot";
	    	$f ~~ /$<cmd>=(__fit__|__plot__|__fit\-only__)* $<file>=(\S+)/;
	    	my $file = $<file>;$cmd = $<cmd>.subst('__','',:g);
	    	my $name = $file.subst(/\.sav|\.json/,'',:g);
	    	shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
	    	"$work-folder/$name".IO.mkdir;
	    	$f.IO.move("$work-folder/$name/$file");
	    	my $engine = Engine.new.path("$work-folder/$name").read("$work-folder/$name/$file");
	    	if $cmd ~~ /plot/ {
				my $time = now;
				say "start plotting $file";
				$engine.plot;
				say "finished plotting $file:", now - $time;
	    	}
	    	elsif $cmd ~~ /only/ {
				my $time = now;
				say "start fitting $file";
				$engine.fit(:no-plot($no-plot),:quiet($quiet)).save("$work-folder/$name/$name" ~ "-fit.json");
				say "finished fitting $file:", now - $time;
	    	}
	    	else {
				my $time = now;
				say "start fitting $file";
				$engine.fit(:no-plot($no-plot),:quiet($quiet)).save("$work-folder/$name/$name" ~ "-fit.json");
				say "finished fitting $file:", now - $time;
	    	}
	    	zip-fit($engine,$work-folder,$name);
		}	
    }
    
    while True {
	my @files = dir('.').grep(*.f).grep(/\.sav|\.json/).words;
		for @files -> $file {
	    	if now - $file.IO.changed > 1 { $supplier.emit($file); sleep 1; }
		    else { sleep 1; }
		}
    }
    
}

multi MAIN  ('create',
	     Str  $function is copy,
	     *@data-files where { @data-files.map({ .IO.e or die("$_ doesn't exist!")}) },
	     Str  :data-label(:$data-labels),
         Str  :$fit-methods = "simp scan min minos",
	     Str  :$tags,
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Bool :$global,
	 	 Bool :ist-ffc-Mz(:$ist-ffc) = False,
		 Str  :$fit-if = "",
		 Str  :$plot-if = "",
		 Str  :$sef-R1-file = "",
		 Str  :$range = "",
		 Bool :$R1 = False,
		 Int  :$gfilt,
		 Str  :set-err(:$err)="",
	     Str  :SymbSize(:$ssz) where { $_.Rat >= 0 }= '1.0',
	     Str  :save-to(:$to), # write fit settings to json or sav file"
	     Str  :$work-folder = '.',
         Int  :Num(:$npts) = +100,
		 Bool :q(:$quiet) = False,
		 Str  :$aux-code = "",
		 *%_
	    ){
	note "onefite options: { %_.keys.map({ "--" ~ $_ }) } not defined...continue..." if %_.keys and !$quiet;
    my $name = "ofe-tmp";
    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
    "$work-folder/$name".IO.mkdir unless "$work-folder/$name".IO.e;
	my %options =();

	%options.push('fit-if' => $fit-if) if $fit-if.so;
	%options.push('plot-if' => $plot-if) if $plot-if.so;
	%options.push('sef-R1-file' => $sef-R1-file) if $sef-R1-file.so;
	%options.push('R1' => $R1) if $R1;
	%options.push('gfilt' => $gfilt) if $gfilt.so;
	%options.push('err' => $err) if $err.so;
	%options.push('range' => $range) if $range.so;

	@data-files = Import.new.path("$work-folder/$name").input-files(@data-files).filter-with(%options, quiet => $quiet);	
	my %aliases = from-json( "{ ::('OFE-PATH') }/../etc/aliases.json".IO.slurp ) if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
	%aliases = %aliases.Slip, from-json("{$*CWD}/aliases.json".IO.slurp).Hash.Slip  if "{$*CWD}/aliases.json".IO.e; 
 	
    if $function.contains(/^ <ws> \w* <ws> ':' <ws>/) { 
		my $falias = %aliases{ $function.subst(/\s*\w*\s*':'?\s*/,'').subst(/\s+/,' ') };
		if so $falias { $function = $falias }
		else { say "function alias not found in { ::('OFE-PATH') }/../etc/aliases.json"; say %aliases.keys;  }
    }
 
    my %e = parse-function($function.subst(/\n|\r/,'',:g), @data-files,$data-labels, path => "$work-folder/$name");
    %e<FitMethods> = $fit-methods;
    %e<FitType>="Global" if $global;
    %e<Num>=$npts;
    %e<SymbSize>=$ssz.Rat;

	if $aux-code.so {	
		my @aux = $aux-code.split(/ <ws> ',' <ws>/);
		%e<AuxCode> = @aux.splice(0,1).IO.slurp;
		%e<AuxDeclar> = "double " ~ @aux.map({ $_.subst(/ <ws> 'double' <ws> /,"",:g) }).join(', ');
	}
    my $engine = Engine.new.path("$work-folder").set(%e);
    $engine.blocks(
	:read,
	:fit,
	:export,
	:autox($autox),
	:autoy($autoy),
	:logx($loglin or $loglog),
	:logy($linlog or $loglog));
    $engine.parameters(:read).functions(:read).stp.code(:write,:compile);
    %e=$engine.h;
    %e<par-tables>:delete;
    if $to.defined { $engine.set(%e).save($to) }
    else { say to-json(%e, :sorted-keys) }
    exit;
}

multi MAIN  ('random',
	     Str  $function, 
	     *@data-files where { @data-files.map({ .IO.e or die("$_ doesn't exist!")}) },
	     Str  :data-label(:$data-labels),
	     Str  :$tags,
	     Str  :$zip-to,
	     Bool :$no-plot,
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Bool :$global,
	     Str  :$save-to, # write fit settings to json or sav file 
	     Str  :$work-folder = '.',
	     Int  :Num(:$npts) = +100,
		 Bool :q(:$quiet) = False,
	    ){
    my %e = parse-function($function.subst(/\n|\r/,'',:g), @data-files,$data-labels);
    %e<FitType>="Global" if $global;
    %e<Num>=$npts;
    for %e.kv -> $k, $v {
	if all($k.contains("Pval"), %e{$k.subst('val','max')}.Bool, %e{$k.subst('val','min')}.Bool) {
	    $k ~~ /Pval $<i>=(\d+)/;
	    %e{$k}= (%e{$k.subst('val','min')}.Real .. %e{$k.subst('val','max')}.Real).rand;
	    %e{'F' ~ $<i>.Str}= "Fix";
	}
    }
    my $name = "ofe-tmp";
    if $zip-to.Bool {
	$name = $zip-to.subst(/\.zip/,'',:g);
    }
    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
    "$work-folder/$name".IO.mkdir;
    for @data-files { $_.IO.copy("$work-folder/$name/$_") };
    my $engine = Engine.new.path("$work-folder/$name").set(%e);
    $engine.fit(
		:no-plot($no-plot),
		:autox($autox or $autoxy),
		:autoy($autoy or $autoxy),
		:logx($loglin or $loglog),
		:logy($linlog or $loglog),
		:quiet($quiet)
    );
    $engine.save($save-to) if $save-to.defined;
    zip-fit($engine,$work-folder,$name) if $zip-to.Bool;
#    shell "pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
    exit;
}

multi MAIN  ('fit',
	Str  $function is copy, 
   	*@data-files where { @data-files.map({ .IO.e or die("$_ doesn't exist!")}) },
   	Str  :data-label(:$data-labels),
   	Str  :$fit-methods = "simp scan min minos",
   	Str  :$tags,
   	Str  :$zip-to,
   	Bool :$no-plot,
   	Bool :auto-x(:$autox),
   	Bool :auto-y(:$autoy),
   	Bool :auto-xy(:$autoxy),
   	Bool :logy(:log-y(:ylog(:$linlog))),
   	Bool :logx(:log-x(:xlog(:$loglin))),
   	Bool :logxy(:log-xy(:$loglog)),
   	Bool :$global is copy,
	Str  :$fit-if = "",
	Str  :$plot-if = "",
	Str  :$sef-R1-file = "",
 	Str  :$range = "",
	Bool :$R1 = False,
	Int  :$gfilt,
	Str  :set-err(:$err)="",
    Str  :SymbSize(:$ssz) where { $_.Rat >= 0 }= '1.0',
    Str  :$save-to, # write fit settings to json or sav file 
    Str  :$work-folder = '.',
    Int  :Num(:$npts) = +100,
	Bool :q(:$quiet) = False,
	Str  :define-alias(:$dali)="",
	Str  :AuxCode(:auxcode(:$aux-code)) = "",
	*%_
    ){
	note "onefite options: { %_.keys.map({ "--" ~ $_ }) } not defined...continue..." if %_.keys and !$quiet;
	my $name = "ofe-tmp";
   	if $zip-to.Bool {
		$name = $zip-to.subst(/\.zip/,'',:g);
   	}
   	shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
    "$work-folder/$name".IO.mkdir unless "$work-folder/$name".IO.e;
	my %options =();

	%options.push('fit-if' => $fit-if) if $fit-if.so;
	%options.push('plot-if' => $plot-if) if $plot-if.so;
	%options.push('sef-R1-file' => $sef-R1-file) if $sef-R1-file.so;
	%options.push('R1' => $R1) if $R1;
	%options.push('gfilt' => $gfilt) if $gfilt.so;
	%options.push('err' => $err) if $err.so;
	%options.push('range' => $range) if $range.so;

	@data-files = Import.new.path("$work-folder/$name").input-files(@data-files).filter-with(%options, quiet => $quiet);	
    
	my %aliases = from-json( "{ ::('OFE-PATH') }/../etc/aliases.json".IO.slurp ) if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
	%aliases = %aliases.Slip, from-json("{$*CWD}/aliases.json".IO.slurp).Hash.Slip  if "{$*CWD}/aliases.json".IO.e; 

    if $function.contains(/^ <ws> \w* <ws> ':' <ws> /) {
		my $falias = %aliases{ $function.subst(/\s*\w*\s*':'?\s*/,'').subst(/\s+/,' ') };
		if so $falias { $function = $falias }
		else { 
			say qq:to/MSG/;
{'-' x 80}
function alias not found in { ::('OFE-PATH') }/../etc/aliases.json or ./aliases.json 
{ %aliases.keys }
{'-' x 80}
MSG
			exit(1);
		}
    }
	if $function.contains(/ 'MIXED' <ws> '=' <ws> '1'/) and !$global {
		note "you are going to performa a MIXED fitting and your optcion global is False. Setting global to True";
		$global = True;
	}
    my %e = parse-function($function.subst(/\n|\r/,'',:g), @data-files,$data-labels, path => "$work-folder/$name");
    %e<FitMethods> = $fit-methods;
    %e<FitType>="Global" if $global;
    %e<Num>=$npts;
    %e<SymbSize>=$ssz.Rat;

	if $aux-code.so {	
		my @aux = $aux-code.split(/ <ws> ',' <ws>/);
		%e<AuxCode> = @aux.splice(0,1).IO.slurp;
		%e<AuxDeclar> = "double " ~ @aux.map({ $_.subst(/ <ws> 'double' <ws> /,"",:g) }).join(', ');
	}

    my $engine = Engine.new.path("$work-folder/$name").set(%e);
    try {
		 $engine.fit(
			:no-plot($no-plot),
			:autox($autox or $autoxy),
			:autoy($autoy or $autoxy),
			:logx($loglin or $loglog),
			:logy($linlog or $loglog),
			:quiet($quiet)
		);
	} 
	if $! {
		my @errors = "ofe-tmp/compile.log".IO.lines.grep(/ error ':' /).map({ .split(/error ':'/).tail.split(';').head  });
		my $msg;
		for @errors {
			if $_.contains('function') {
				my $undeclared = "ofe-tmp/compile.log".IO.lines.grep(/undeclared/).map({ .words[6].subst(/';'|<[']>/,'',:g) ~ '()' }).join(','); 
				$msg = qq:to/MSG/;
Consider using --aux-code=\"AuxCode-file.c, double $undeclared, ...\"
to add the undeclared functions
MSG
			}
			else {
				my @arguments = $function.split(/ ')' <ws> '=' /).head.split(/'('/).tail.split(',');
				@arguments.push: $_.words.tail.subst(/ ';'|'\''/,'',:g);
				$msg = qq:to/MSG/;
Consider resetting your function's arguments list to ({ @arguments.join(', ') })
MSG
			}
		}
		say qq:to/MSG/;
$! 
{@errors.join("\n")}
{'-' x 80}
$msg
{'-' x 80}
MSG
		exit(1);
	}
    $engine.save($save-to) if $save-to.defined;
    zip-fit($engine,$work-folder,$name) if $zip-to.Bool;

    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";

	define-alias($engine,$dali) if $dali.so;
    exit;
}

multi MAIN  ('fit',
     Str  $input-file, # name of the (sav or json) to compile
     Str  :$fit-methods = "simp scan min minos",
     Bool :$no-plot,
     Bool :auto-x(:$autox),
     Bool :auto-y(:$autoy),
     Bool :auto-xy(:$autoxy),
     Bool :logy(:log-y(:ylog(:$linlog))),
     Bool :logx(:log-x(:xlog(:$loglin))),
     Bool :logxy(:log-xy(:xy-log(:$loglog))),
     Str  :save-to(:$to), # write fit settings to .json or .sav file 	     
     Str  :$zip-to = $input-file.IO.extension('').Str,
     Str  :$work-folder = '.',
     Int  :Num(:$npts),
	 Bool :$export = False,
	 Bool :q(:$quiet) = False,
	 Str  :define-alias(:$dali)="",
	 *%_
    ){
	do {
		say "{'-' x 80}\nfile $input-file dosen't exist\n{'-' x 80}";
		exit(1);
	} unless $input-file.IO.e;
	note "onefite options: { %_.keys.map({ "--" ~ $_ }) } not defined...continue..." if %_.keys and !$quiet;
	my $name = $input-file.subst(/\.sav|\.json/,'',:g);
	shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
	try {
		"$work-folder/$name".IO.mkdir;
	}
	if $! {
		my @args = @*ARGS;
		my $msg;
		if @*ARGS[1].contains(':') {
			@args[1] = '"alias' ~ @args[1] ~ '"';
			$msg = qq:to/MSG/;
{'-' x 80}
I am not sure about your list of arguments: \"{ @*ARGS[0] ~ ' "' ~ @*ARGS[1] ~ '" ' ~ @*ARGS[2..*].join(' ') }\" 
{ @*ARGS[1].contains(':') ?? 'I think you mean \'onefite ' ~ @args.join(' ') ~ '\''  !! ''}
{ '"alias' ~ @*ARGS[1] ~ '"'}, { '"a' ~ @*ARGS[1] ~ '"'}, or { '" ' ~ @*ARGS[1] ~ '"'} also work
{'-' x 80}
MSG
		}
		else {
			@args[1] = '"<missing function>" ' ~ @args[1] ;
			$msg = qq:to/MSG/;
{'-' x 80}
I am not sure about your list of arguments: \"{ @*ARGS[0..*].join(' ') }\" 
I think you mean \'onefite {  @args.join(' ') }\' 
{'-' x 80}
MSG
		}
		say $msg;
		exit(1)
	}
	$input-file.IO.copy("$work-folder/$name/$input-file");
	my $engine = Engine.new.path("$work-folder/$name").read("$work-folder/$name/$input-file");
#	my $engine = OFE::Engine.new.path("$work-folder").read($input-file);
	if $export {
		my $basename = $input-file.IO.extension("").Str; 
		"data-$basename.txt".IO.spurt: $engine.h<Dados>;
		"AuxCode-$basename.c".IO.spurt: $engine.h<AuxCode>;
		note qq:to/MSG/;
{'-' x 80}
data exported to: data-$basename.txt
AuxCode exported to: Auxcode-$basename.c
{'-' x 80}
MSG
	}
	else {
		my $basename = $input-file.IO.extension("").Str; 
		note qq:to/MSG/;
{'-' x 80}
consider using --export to export data to: data-$basename.txt
and to export AuxCode to: Auxcode-$basename.c
{'-' x 80}
MSG
	}

    $engine.Num($npts) if $npts.Bool;
    $engine.fit-methods($fit-methods);
    $engine.fit(
			:no-plot($no-plot),
			:autox($autox or $autoxy),
			:autoy($autoy or $autoxy),
			:logx($loglin or $loglog),
			:logy($linlog or $loglog),
			:quiet($quiet)
	    );
    $engine.save($to) if $to.defined;
    zip-fit($engine,$work-folder,$name);
    shell "mv $name.zip $zip-to" unless $name eq $zip-to;
    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";

	define-alias($engine,$dali) if $dali.so;
    exit;
}


multi MAIN  ('plot',
	     Str $input-file where { $input-file.IO.e or die "$input-file dosen't exist!" }, # name of the (sav or json) to compile
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Str  :$work-folder = '.',
	     Int  :Num(:$npts)
	    ){
	    my $name = $input-file.subst(/\.sav|\.json/,'',:g);
	    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
	    "$work-folder/$name".IO.mkdir;
	    $input-file.IO.copy("$work-folder/$name/$input-file");
	    my $engine = Engine.new.path("$work-folder/$name").read("$work-folder/$name/$input-file");
	    #	    my $engine = Engine.new.path("$work-folder").read($input-file);
	    $engine.Num($npts) if $npts.Bool;
	    $engine.plot(
		:autox($autox or $autoxy),
		:autoy($autoy or $autoxy)
		:logx($loglin or $loglog),
		:logy($linlog or $loglog)
	    );
	    zip-fit($engine,$work-folder,$name);
	    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
	    exit;
}


multi MAIN ('test','list') {
    my $test-path=OFE-PATH ~ "/t";
#    my $test-path=OFE-PATH.subst("rakumod/OFE","t");
    dir($test-path).grep(*.f).grep(/rakutest/).map( { .subst("$test-path/","",:g).say });
}	    

multi MAIN ('test',
	    *@arr,
		Bool :d(:$systemd-daemon) = True,
		Bool :p(:$post-install) = True,
	    Bool :verbose(:$v) = False
	   ){
    my $test-path=OFE-PATH ~ "/t";
#    my $test-path=OFE-PATH.subst("rakumod/OFE","t");

    "/tmp/OneFit-Engine-test".IO.mkdir unless "/tmp/OneFit-Engine-test".IO.d(:e);
    
    if @arr.elems > 0 {
		my $fho = open :w, '/tmp/tests.log';
		@arr.race.map({
			my $test = "$_.rakutest" unless .contains(/rakutest/);
			say "testing....$test"; run "raku", "$test-path/$test" , :err<fho>
	    });
		$fho.close;
		"/tmp/tests.log".IO.slurp.say;
    }
    else {
		my $proc = run "prove6", "--lib", "$test-path","--err=ignore";
    }
    run-post-install-tests(:daemon($systemd-daemon), :verbose($v)) if $post-install;
    exit;
}

multi MAIN (Bool :v(:$version))
{
    my %meta = from-json( "{ ::('OFE-PATH') }/META6.json".IO.slurp );	
    my $txt = "OneFit-Engine version: "  
			~ %meta<version> 
			~ " "
			~ shell("zef locate OneFit-Engine",:out).out.slurp;
	say $txt;
	return $txt
}


sub parse-function ($function, @data-files, $data-labels, Str :$path = ".") {
    my %e = OneFit::Engine::Grammars::Function.parse-me($function);
    %e<FitType T Num> = <Individual dum 100>;
    %e<SelectedDataSet> = @data-files[0].subst(".dat","");
    for (1 .. @data-files.elems) {
	my @lines="$path/{@data-files[$_-1]}".IO.lines;
	my $label = "dum";
	my $dum=$_;
	$dum = @lines.head if @lines.head.words.elems < 2;
	if @lines.grep(/DATA/) {
	    $label = @lines.grep(/DATA/).split("=")[0].split("DATA")[1].words[0];
	    $dum = @lines.grep(/DATA/).split("=")[1];
	    %e<T> = $label;
	    shift @lines;
	}
	if @lines.grep(/TAG/) {
	    shift @lines;
	}
	if $data-labels.defined {
	    my $dum-parse = OneFit::Engine::Grammars::Label.parse($data-labels);
	    $label = $dum-parse<name>.Str;
	    %e<T> = $label;
	    if $dum-parse<values> > 0 { $dum = $dum-parse<values>[$_-1].Str.join(' ') }
	}
	%e<Dados> ~= "\n# DATA $label = $dum\n";
	%e<Dados> ~= "# TAG = { @data-files[$_-1].subst(".dat","") }\n";
	%e<Dados> ~= @lines.join("\n") ~ "\n\n";
	%e<Tags>.push: @data-files[$_-1].subst(".dat","");
    }
    return %e;
}

sub zip-fit ($engine,$work-folder,$name) {
    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
    my $excluded =  { "$work-folder/$name/" <<~<< <AuxCode.* onefit-user *.h *.c *.o *_ gnu* *.stp> }().join(' ') ;
    "$name.zip".IO(:e).unlink;
    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
    shell "zip -q -r $work-folder/$name.zip $work-folder/$name -x $excluded";
}

sub run-post-install-tests(Bool :$daemon = True, Bool :$verbose = False) {
    my $data = q:to/EOT/;
# DATA dum = 40616
# TAG = zone12
# R1 = 16.9554
2.4 0.4950845801988824 1
1.60968 0.5030929382053178 1
1.07962 0.5071383400239955 1
0.724101 0.5192948321930172 1
0.485656 0.5160022771910805 1
0.32573 0.5291235757829099 1
0.218468 0.5350239458592603 1
0.146527 0.5898993575693909 1
0.098276 0.6180204586347606 1
0.065914 0.6826722682863811 1
0.044208 0.752954560068173 1
0.029651 0.8279391722256552 1
0.019887 0.8918345724621874 1
0.013338 0.9470250641189731 1
0.008946 0.9713798167045512 1
0.006 1.0 1.0 
EOT


        say "Running post-install tests...\n";
        "/tmp/zone12.dat".IO.spurt: $data;
	my $service = $daemon ?? shell("systemctl status onefite",:out).out.slurp(:close).contains("active (running)") !! False;
	if $service {
	    put "testing localhost onefite web service... ";
	    my $result = "curl --silent -F \"file=\@zone12.dat\" -F \"autox=yes\" -F \"logx=yes\" -F \"function=Mz[-2<2](t,M0,Mi,T1[0.01<3])=Mi \+ (M0-Mi)*exp(-t/T1)\" http://127.0.0.1:8142/fit --output ofe-test.log";
	    say $result if $verbose;
	    $result = shell("cd /tmp && $result");
		if !$result.exitcode {
		    $result = "/tmp/ofe-test.log".IO.slurp(:close);
		    say $result if $verbose;
	    	if $result.contains("zone12, 16") { put "OK\n"; }
	    	else { put "error!\n"; }
		}
		else { say "Curl exitcode: { $result.exitcode }. Unsuccessfull test of onefite web service!"; }
	}
	else {
	   	my $pid = shell("onefite service PID",:out).out.slurp(:close);
		if $pid.so {
			say "onefite is running with PID: $pid";
			my $result = "curl --silent -F \"file=\@zone12.dat\" -F \"autox=yes\" -F \"logx=yes\" -F \"function=Mz[-2<2](t,M0,Mi,T1[0.01<3])=Mi \\+ (M0-Mi)*exp(-t/T1)\" http://127.0.0.1:8142/fit --output ofe-test.log";
			say $result if $verbose;
	   		$result = shell("cd /tmp && $result");
			if !$result.exitcode {
	   			$result = "/tmp/ofe-test.log".IO.slurp(:close) if "/tmp/ofe-test.log".IO.e;
				say $result if $verbose;
	   			if $result.contains("zone12, 16") { say "localhost web service works OK"; }
	   			else { say "localhost web service error!"; }

			}
			else { say "Curl exitcode: { $result.exitcode }. Unsuccessfull test of onefite web service!"; }
		}
		else { say "onefite service if off in all ports" }
	}
	my &fileowner = { my $file = $^a; shell("ls { $file.IO.d ?? '-ld' !! '-la'} $file | awk '\{print \$3\}'",:out).out.slurp(:close) };
	</tmp/ofe-tmp>.map({ $_.IO.e and fileowner($_).contains("root") ?? shell("sudo rm -fr $_") !! shell("rm -fr $_") });

	put "testing command line onefite...";
	my $result = shell("cd /tmp/ && onefite fit \"Mz[-2<2](t,M0,Mi,T1[0.01<3])=Mi \+ (M0-Mi)*exp(-t/T1)\" zone12.dat --autox --logx", :out).out.slurp(:close);
	say $result if $verbose;
	if $result.contains("zone12, 16") {
	    put "OK\n";
	}
	else {
	    put "error!\n\n";
	}
	</tmp/ofe-tmp /tmp/OneFit-Engine-test /tmp/zone12.dat /tmp/ofe-test.log>.map({ $_.IO.e and fileowner($_).contains("root") ?? shell("sudo rm -fr $_") !! shell("rm -fr $_") });
}

sub define-alias($engine,$dali) {
		if $dali.so {
			my @p = $engine.h<par-tables>;
			my @pars;
			for 0 ..^ @p.head.head.elems {
				my $par;
			   	if all(@p.head.head[$_]<min>, @p.head.head[$_]<max>) {
					$par = @p.head.head[$_]<name>  
						~ "{ @p.head.head[$_]<free> ?? ':' !! '=' }"
						~ @p.head.head[$_]<value>
						~ '['
						~ @p.head.head[$_]<min>
			   			~ '<'
						~ @p.head.head[$_]<max>
						~ ']';
				}
				else {
					$par = @p.head.head[$_]<name>  
						~ "{ @p.head.head[$_]<free> ?? ':' !! '=' }"
						~ @p.head.head[$_]<value>;
				}
				@pars.push: $par;
			}
			my $X =   $engine.h<X> ~ 
				'[' ~ $engine.h<Xmin>.subst('\\',"",:g).split(",").head ~ 
				'<' ~ $engine.h<Xmax>.subst('\\',"",:g).split(",").head ~
				']';
			my $Y =  $engine.h<Y> ~ 
				'[' ~ $engine.h<Ymin>.subst('\\',"",:g).split(",").head ~
				'<' ~ $engine.h<Ymax>.subst('\\',"",:g).split(",").head ~ 
				']';
			my $value = "$Y\( $X, { @pars.join(', ')} \) = "
						~	
						$engine.h<Function>.subst(/\n|\r/,"",:g).split('=').tail;
			my %aliases;
			%aliases = from-json("./aliases.json".IO.slurp) if "./aliases.json".IO.e;
			%aliases{$dali}=$value;
			"./aliases.json".IO.spurt: to-json(%aliases, :sorted-keys);
			note "{'-' x 80}\nalias $dali replaced in ./aliases.json\n{'-' x 80}";
		}
}

=begin pod

=NAME 
	onefite - Raku script interface to the OneFit-Engine (OFE)

=SYNOPSIS
	onefite stands for OneFit Engine, OFE for short. It helps users to perform model fits to data. 
	It aims at obtaining the "best fit with just one go" keeping true to the fitteia's moto 

	"Keeping the simple easy, making the complex feasible, and getting the impossible within reach."  

=NOTE
	This man page is expected to help you to take full advanatge of onefite both on the server and on the client sides
	


=DESCRIPTION 
		this is it

=USAGE

=head2 Basic commands

=item1 onefite
=begin code :lang<bash>
onefite [-h|--help]
=end code

	Options

	[-h|--help] Basic help

=item1 Uninstall
=begin code :lang<bash>
 onefite uninstall
=end code

=item1 Help on models
=begin code :lang<bash>
 onefite help <model> [-q|--quiet]
 onefite help <model> <key>] [-q|--quiet]
=end code
	
	Provides information on the <model> equation included in the models fitting library
	Sub-option <key> provides just the specific information on the key 

	Options

	[-q|--quiet] No screen print of log information 

=item1 List models
=begin code :lang<bash>
onefite list [-q|--quiet]
onefite list models [-q|--quiet]
onefite list aliases [-q|--quiet]
=end code
	
	Lists models included in the models fitting library and aliases defined in $HOME/.local/etc/aliases.json)i
	Lists just the models
	Lists just the aliases

	Options

	[-q|--quiet] No screen print of log information 

=item1 Paths finder
=begin code :lang<bash>
onefite path [-s|--src] [-t] [-e|--examples] [-b|--bin] [-l|--lib] [-c|-C] [--log] [-a|--aliases]
=end code

	Paths to OneFit-Engine folders installed. 
	Combined use with "cd" and "awk" in the examples below

	Options

	[-s|--src] Source
	[-t] Raku test folder
	[-e|--examples] Examples folder
	[-b|--bin] Binaries folder
	[-l|--lib] Libraries folder
	[-c|-C] C code/F code folders
	[--log] Log folder
	[-a|--aliases] Aliases folder
	
	Examples

	cd $(onefite path -s)
	vi $(onefite path -a)/aliases.json

=head2 Files conversion

=item1 sav <--> json files conversion
=begin code :lang<bash>
onefite convert <input-filename> <output-filename> [--work-folder=<Str>]
=end code
	
	Converts fitteia's sav files to OFE json files

	Options

	[--work-folder] Folder where the coversion will be performed

	Examples
	
	onefite convert some-fitteia-fit.sav ofe-version.json


=head2 OFE service commands

=item1 Systemd service 

=begin code :lang<bash>
onefite service start [--ip=<Str>] [-d|--systemd-deamon] [-p|--port=<Int>]
onefite service stop
=end code

	[start] Is: sudo systemctl daemon-reload; systemctl enable onefite.service; service onefite start
	[stop] Is: kill -9 <star-web-service>
	[--ip=<Str>] Is: '*' by default. When [--macos] or [--wsl] use --ip=127.0.0.1
	[-p|--port=<Int>] Is: 8142 byt default. Check your Firewall just in case
	[-d|--systemd-daemon] Is: False by default. When [--docker] [--macos] or [--wsl] keep the default.

=item1 LOG and PID services

=begin code :lang<bash>
onefite service log|PID
=end code

	Shows log OFE service log file	
	Prints OFE Process IDentifier 

=item OFE manual web service

=begin code :lang<bash>
onefite start-web-engine [--ip[=Any]] [-p|--port[=Any]]
onefite stop-web-engine
(OBSOLETE) onefite start-engine [--no-plot] [-q|--quiet] [--work-folder=<Str>]
=end code

	User command line to start|stop OFE web service

=head2 Create command

=begin code :lang<bash>
onefite create <function> <data-files> ... [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global]  [--R1] [--sef-R1-file=<Str>] [--fit-if=<Str>] [--plot-if=<Str>] [--set-err|--err=<Str>] [--gfilt=<Int>] [--range=<Str>] [--SymbSize|--ssz=<Str>] [--save-to|--to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]] [-q|--quiet]
=end code

	Creates a json file with the function and datafiles provided.

	Function

	The function syntax has the follwing rules:
		[ x < y ] Defines a range of vales [ x ; y], that is between x and y, inclusive. Spaces can be removed. '<' and ';' can be use as limits separators but '<' present less escape issues in argument passing   
    	':'	Initializing symbol
		'=' Fix a value

	Example

		"Mz [ -1 < 1] ( t[1e-3 < 10], M0:0.5[-1<1], Mi=1[-2<2], T1:0.5 [ 1e-3 < 10]) = Mi \+ (M0-Mi)*exp(-t/T1)"
		Mz is the dependent variable with a plot range will be form -1 to 1. Mz is a function with arguments: t,M0,Mi, and T1
		t  is the independent variable with a plot range between 1e-3 and 10
		M0 is a model parameter initiallized to 0.5 and the non linier Least-Squares minimization performed by CERN lib MINUIT will be restrited to the range [-1;1]
		Mi is a model parameter with a fixed value 1 but a possible range [-2;2]
		T1 is a model parameter initialized to 0.5 in a range [1e-2; 10]
	
		The expression "Mi \+ (M0-Mi)*exp(-t/T1)" contains '\+' that sets the plotting individual model contributions option to True

	Options

=head2 Fit commands

=begin code :lang<bash>
onefite random <function> <data-files> ... [--data-label|--data-labels=<Str>] [--tags=<Str>] [--zip-to=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--save-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]

onefite fit <function> <data-files> ... [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--zip-to=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global]  [--R1] [--sef-R1-file=<Str>] [--fit-if=<Str>] [--plot-if=<Str>] [--set-err|--err=<Str>] [--gfilt=<Int>] [--range=<Str>] [--SymbSize|--ssz=<Str>] [--save-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]] [-q|--quiet [--define-alias|--dali=<Str>] [--aux-code=<Str>]

onefite fit <input-file> [--fit-methods=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--save-to|--to=<Str>] [--zip-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int] [-q|--quiet] [--define-alias|--dali=<Str>] [--export]

onefite plot <input-file> [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--work-folder=<Str>] [--Num|--npts[=Int]]

	Options
	
	[--define-alias|--dali=<Str>] adds alias Str do the function used to fit the date in the ./aliases.json file. Overwrites exiting alias
	[--export] to write data and AuxCode in files for later use with onefite fit <funtion>
   	[--aux-code] accepts the name of the file with the AuxCode and the new fitting functions declarations	

	Examples

	onefite fit "Mz(t[1e-3<20],M0,Mi,T1[1e-3<10])=Mi\\+(M0-Mi)*exp(-t/T1)" file.hdf5 --autox --logx --autoy
	onefite fit "Mz(t[1e-3<20],M0,Mi,T1[1e-3<10])=Mi\\+(M0-Mi)*exp(-t/T1)" file.hdf5 --autox --logx --autoy --define-alias=1exp

	onefite fit "alias: 1exp" file.hdf5 --autox --logx --autoy
	onefite fit "a: 1exp" file.hdf5 --autox --logx --autoy

	onefite fit "a: 1exp" file.txt --autox --logx --autoy
	onefite fit "a: 2BPP" *.dat --autox --logx --autoy --logy
	onefite fit "a: 1BPP" file.zip --autox --logx --autoy --logy
	onefite fit "a: 1BPP" file.zip --autox --logx --autoy --logy
	onefite fit "a: 1BPP" file.zip --autox --logx --autoy --logy --define-alias=1BPP
	onefite fit "y(x,a,b) = a \+ b*x" file.dat --set-err="1.0" 
	onefite fit "y(x,a,b) = a \+ b*x" file.dat --set-err="1%" 
	onefite fit "y(x,a,b) = a \+ b*x" file.dat --set-err="std" 
	onefite fit "y(x,a,b) = a \+ b*x" file.dat --set-err="standard deviation" 
	onefite fit "y(x,a,b) = a \+ b*x" file.dat --set-err="std split at 5" 
	onefite fit "y(x,a,b) = a \+ b*x" file.dat --set-err="1% avg" 
	onefite fit "y(x,a,b) = a \+ b*x" file.dat --set-err="1% average" 
	onefite fit "y(x,a,b) = a \+ b*x" file.dat --set-err="10% avg split at 10.5"


=end code

=head2 Version upgrade

=begin code
onefite upgrade [-u|--to-user] [-c|--compile] [-d|--systemd-daemon] [--test=<Str>] [--ip=<Str>] [-p|--port[=Int]] [-m|--merge-site=<Str>] [--cernlib] [--shell] [--shell-port=<Int>] [--wsl] [--macos] [--docker] [--dpkg]
=end code

	At the host prompt run I<onefite updatde -d --shell --test>  

	This will upgrade the current (main or dev) version of the OneFit-Engine. github.com/fitteia/OneFit-Engine.git 
	is downloaded and expanded. OneFit-Engine/INSTALL is called with options --system-daemon and --shell an --test options.  
	Port 8142 will be open to onefite requests.
	Port 8100 will be open to shell command accces via a web browser 

	Options
	
	[-c|--compile] Compile the OneFit-Engine C and F source.  Default is True
	[--ip] Ip range access to the OneFit-Engine web service. Default '*' (All)
	[-p] Port number for the OneFit-Engine web service. Default 8142
	[-m|--merge-site=<Str>] Git pull OneFit-Engine and merge with local site <Str> sources. Default ''

	[-u|--to-user] Install OneFit-Engine in the user space.  Default is False
	[-d|--systema-daemon] Create a systemd service.config and install service.  Default is False
	[--test] Run install tests.  Default False
	[--cernlib] Use debian cernlib package or compile fortran version from source. Default False
	[--shell] Install debian package to create a wes shell service on defaul port 8100 or port define in option --shell-port. Default False
	[--shell-port] Port number for the web shell service. Default 8100
	[--dpkg] run apt update by default. Use --no-dpkg otherwise
	Use --/<option> or --no-<option> for disable default option value (ex: --no-test or --/test)	

=head2 Test commands

=begin code :lang<bash>
onefite test list

onefite test [<arr> ...] [--verbose|-v] [-d|systemd-daemon] [-p|--post-install]
=end code


=PARAMETERS
=head2 File parameters
=item input-file- name of the file to be converted (file extensions: sav or json)
=item output-file- name of the converted file (file extensions: sav or json)
=item data files- can be one or more files including plain text ASCII (.dat, .txt). Zip files are accepted.
	Special cases: Stelar S.R.l files (.sdf, .hdf5, .sef).

=head2 Fit methods
=item fit-methods - simp scan min minos


=para 

=end pod


