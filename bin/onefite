#!/usr//bin/env raku

my $time = BEGIN { now }
END { note "Total execution time (s): " , now - INIT now }

note "Compile time: ", now - $time;

our constant OFE-PATH="%OFE-PATH%";

use OneFit;
use OneFit::Engine::Grammars;
use OneFit::Engine::Parameters;
use OneFit::Engine::Parfiles;
use OneFit::Engine::Stpfiles;
use OneFit::Engine::Import;
use Pod::To::Text;
use Pod::To::Man;
use Test;

use Cro::HTTP::Router;
use Cro::HTTP::Server;
use Cro::HTTP::Log::File;
use JSON::Fast;

my %*SUB-MAIN-OPTS =  :named-anywhere, :allow-no, :bundling ;

multi MAIN (Bool :$man!) {
	my $txt = pod2text $=pod;
	say $txt;
	$txt
}


multi MAIN (Bool :h(:help($))) {
#        say 'onefite is a script that implements fitteia.org fitting settings and fitting strategies in the form of a fiiting engine access√≠ble from the command line';

	#    my $p= shell "onefite help", :err;
	#    say $p.err.slurp(:close);
	note qq:to/END_USAGE/;
    Usage:
        onefite [-h|--help]
		onefite [--man]
	    onefite uninstall
	    onefite service start
	    onefite service stop
	    onefite service log
	    onefite service PID
	    onefite list [-q|--quiet]
	    onefite list models [-q|--quiet]
	    onefite list aliases [-q|--quiet]
	    onefite path [-s|--src] [-t] [-e|--examples] [-b|--bin] [-l|--lib] [-c|-C] [--log] [-a|--aliases]
	    onefite convert <input-file> <output-file> [--work-folder=<Str>]
	    onefite upgrade [-u|--to-user] [-c|--compile] [-d|--systemd-daemon] [--test=<Str>] [--ip=<Str>] [-p|--port[=Int]] [-m|--merge-site=<Str>] [--cernlib] [--shell] [--shell-port=<Int>]
	    onefite start-web-engine [--ip[=Any]] [-p|--port[=Any]]
	    onefite stop-web-engine
	    onefite help <model> [-q|--quiet]
	    onefite help <model> <key>] [-q|--quiet]
	    onefite start-engine [--no-plot] [-q|--quiet] [--work-folder=<Str>]
            onefite create <function> [<data-files> ...] [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--stelar-hdf5] [--ist-ffc] [--ist-ffc-R1] [--ist-ffc-R1-err=<Rat>] [--stelar-sdf] [--stelar-sdf-Re] [--stelar-sdf-Im] [--stelar-sef] [--stelar-sef-R1] [--stelar-sef-R1-err=<Rat>] [--stelar-hdf5-Re] [--stelar-hdf5-Im] [--stelar-hdf5-R1] [--stelar-hdf5-R1-err=<Rat>] [--SymbSize|--ssz=<Str>] [--save-to|--to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
	    onefite random <function> [<data-files> ...] [--data-label|--data-labels=<Str>] [--tags=<Str>] [--zip-to=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--save-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
            onefite fit <function> [<data-files> ...] [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--zip-to=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--ist-ffc] [--ist-ffc-R1] [--ist-ffc-R1-err=<Rat>] [--stelar-sdf[=<Str>]] [--stelar-sdf-Re[=<Str>]] [--stelar-sdf-Im[=<Str>]] [--stelar-sef] [--stelar-sef-R1[=<Str>]] [--stelar-sef-R1-err=<Rat>] [--stelar-hdf5] [--stelar-hdf5-Re] [--stelar-hdf5-Im] [--stelar-hdf5-R1] [--stelar-hdf5-R1-err=<Rat>] [--SymbSize|--ssz=<Str>] [--save-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
	    onefite fit <input-file> [--fit-methods=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--save-to|--to=<Str>] [--zip-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
	    onefite plot <input-file> [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--work-folder=<Str>] [--Num|--npts[=Int]]
	    onefite test list
	    onefite test [<arr> ...] [--verbose|-v]
  
	    <input-file>     name of the file to be converted (\.sav or \.json)
	    <output-file>    name of the converted file (\.sav or \.json)
	    fit-methods: simp scan min minos

	    <function> syntax alternatives:
    \"y(x,a,b,c)=a + b*x + c*pow(x,2.0)\"
    \"y(t,A,lambda: 0.1)=A*exp(-lambda*t)\" 0.1 is the initial value to start mimimization
    \"y (t,A,B=2,lambda)=A * (1 - B*exp(-lambda*t) )\" B is fixed with value 2
    \"y( t,A, lambda: [0;0.5])=A*exp(-lambda*t)\" [lambda is limited to range 0 to 0.
    \"R1(f:[0;1e9], A, tau[0<1e-9])=A*tau/(1+pow(2*pi*f*tau,2.0)\" f is limite to positive values up to 1e9 and tau also
    \"y[-1;1](x:[0<1],a,b,c)=a + b*x + c*x*x\" theoretical curves generated for x is limited to range 0 to 1; in the plot y axis will be limited to range -1 to 1
    \"f(x,p1: 2, p2=0.3, p3[5<10]) :[-5;5]=p1*exp(-p2*x)*sin(2*pi*x/p3)\" p1 is initialized to 1, p2 is fixed to 2 p3 will be in the range 5 to 10
END_USAGE
}

multi MAIN ('list',
      	   Bool :q(:$quiet) = False
	   ){
#    my @list = dir(::('OFE-PATH') ~ "/C/local");
#    @list.push: dir(::('OFE-PATH') ~ "/C/core/onefit-3.1/modelos").Slip;
#    @list = @list.grep(*.f).grep(/\.c/)>>.basename>>.IO>>.extension('').sort;
#    my $txt = "OneFit Engine Models Library:\n";
#    $txt ~= @list.join("\n");
     my $txt = MAIN('list', 'models', quiet => True);
     #my $txt = "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp;
    $txt ~= MAIN('list', 'aliases', quiet => True); 
    #$txt ~=  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.slurp  if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
    say $txt unless $quiet;
    $txt;
}

multi MAIN ('list','models',
      	   Bool :q(:$quiet) = False
	   ){
     my $txt = "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp;
     say $txt unless $quiet;
     $txt;
}

multi MAIN ('list','aliases',
      	   Bool :q(:$quiet) = False
	   ){
	my $txt = "{ ::('OFE-PATH') }/../etc/aliases.json".IO.slurp  if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
	if not $quiet {
           say "listing aliases @  { ::('OFE-PATH') }/../etc/aliases.json"  if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
	   say $txt;
	}
	$txt;
}

multi MAIN ('convert',
	    Str $input-file where { $input-file.IO.e or die "$input-file dosen't exist!" }, # name of the file to be converted (sav or json)
	    Str $output-file, # name of the converted file (sav or json)
            Str :$work-folder = "."
	   ) {
    my $eng = Engine.new.path($work-folder).read($input-file).blocks(:r).parameters(:r).functions(:r).code(:write,:compile).save($output-file);
    return 0;
}

multi MAIN ('path',
      Bool :s(:$src) = False,
      Bool :$t = False,
      Bool :e(:$examples) = False,
      Bool :b(:$bin) = False,
      Bool :l(:$lib) = False,	
      Bool :c(:$C) = False,
      Bool :$log = False,
	  Bool :a(:$aliases) = False
      ){
      if none($src,$t,$bin,$lib,$C,$examples,$aliases) {
      	 say ::('OFE-PATH');
		 say ::('OFE-PATH') ~ "/t";
		 say ::('OFE-PATH') ~ "/examples";
		 say ::('OFE-PATH') ~ "/lib";
		 say ::('OFE-PATH') ~ "/bin";
		 say ::('OFE-PATH') ~ "/../bin";
		 say ::('OFE-PATH') ~ "/../log";
	 	 say ::('OFE-PATH') ~ "/C";
	 	 say ::('OFE-PATH') ~ "/../etc";
      }
      else {
      	 say ::('OFE-PATH') if $src;
		 say ::('OFE-PATH') ~ "/t" if $t;
		 say ::('OFE-PATH') ~ "/examples" if $examples;
		 say ::('OFE-PATH') ~ "/lib" if $lib;
		 say ::('OFE-PATH') ~ "/../bin" if $bin;
		 say ::('OFE-PATH') ~ "/../log" if $log;
		 say ::('OFE-PATH') ~ "/C" if $C;
		 say ::('OFE-PATH') ~ "/../etc" if $aliases;
      }
}

multi MAIN ('upgrade',
      Bool :u(:$to-user) = False,
      Bool :c(:$compile) = True,
      Bool :d(:$systemd-daemon) = False,
      Bool :$cernlib = False,
      Bool :$shell = False,
      Int  :$shell-port = 8100,
      Str  :$ip = '*',
      Int  :p(:$port) = 8142,
      Str  :$test = '--/test',
      Str  :m(:$merge-site) = '',
      ){
      shell "sudo service onefite stop" if $systemd-daemon and !$to-user and shell("sudo systemctl list-units | awk \'/^onefite/ \{print \$1\}\'",:out).out.slurp.Bool;
      
      shell "cd $*HOME/.local/OneFit-Engine && git stash && git pull && ./INSTALL { ($to-user) ?? '--to-user' !! '' } { '-/c' unless $compile } { '-d' if $systemd-daemon } $test --ip=$ip --port=$port { ($merge-site.Bool) ?? '-m=' ~ $merge-site !! '' } { '--cernlib' if $cernlib } { "--shell --shell-port=$shell-port" if $shell }";
      MAIN('service','start',:systemd-daemon(all($systemd-daemon,!$to-user)),ip => $ip, port => $port)
}

multi MAIN ('uninstall'){
      MAIN('stop-web-engine');
      shell "cd $*HOME/.local/OneFit-Engine && git stash && git pull && ./INSTALL -U";
      exit;  
}

multi MAIN ('service','start',	
      Bool :d(:$systemd-daemon) = False,
      Str  :$ip = '*',
      Int  :p(:$port) = 8142,
      ) {
      if $systemd-daemon {
           say "stoping onefite service...";
      	   my $proc = shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1];
      	   shell "sudo kill -9 $proc" if so $proc;
           shell 'sudo systemctl daemon-reload';
	   shell 'sudo systemctl enable onefite.service';
	   shell 'sudo service onefite start';
	   say "service onefite started on IPv4 $ip and port $port";
      }
      else {           
            say "stoping onefite service...";
      	    my $proc = shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1];
      	    shell "kill -9 $proc" if so $proc;
      	    say "starting onefite service on $*HOME/public_html and go in the backgound";
      	    shell "cd $*HOME/public_html; nohup onefite start-web-engine --ip=$ip --port=$port &";
      }
      exit
}

multi MAIN ('service','stop') { MAIN('stop-web-engine'); exit }

multi MAIN ('service','log') { "{ ::('OFE-PATH') }/../log/onefite".IO.slurp.say; exit }

multi MAIN ('service','PID') { shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1].say; exit }

multi MAIN ('stop-web-engine'){
      my $proc = shell("ps aux", :out).out(:close).lines.grep(/start\-web\-engine/).words[1];
      shell "kill -9 $proc" if so $proc;
}

multi MAIN ('start-web-engine',
	    :$ip = from-json(shell("ip -4 -br -j add",:out).out.slurp(:close)).tail<addr_info>.head<local>,
	    :p(:$port) = 8142,   
	   ){
	   my $log-file="{ ::('OFE-PATH') }/../log/onefite";
	   my $log-fh = open($log-file, :a);
    my $application = route {
	   get -> {
	     $log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) get webform");
	     $log-fh.flush;

	       content 'text/html', q:to/HTML/;
               	<!DOCTYPE html>
            	<html>
           	 <head>
            	   <title>OneFit Engine Web Server</title>
            	 </head>
            	  <body>
            	     <h1>OneFit Engine Web Server</h1>

            	     <form action="/fit" method="post" enctype="multipart/form-data">
            	     Upload file [.json | .sav | .hdf5 | data-file ] <input type="file" name="file"><br/>
		       Download: <input type="text" name="download" value="zip"><br/>
		       Username: <input type="text" name="username" value="<username>"><br/>
		       Num points: <input type="text" name="Num" value="100"><br/>
		       Symbol size: <input type="text" name="SymbSize" value="1.0"><br/>
		       Fit methods: <input type="text" name="fit-methods" value="simp scan min minos"><br/>
		       Data file fitting function: <textarea rows="1" cols="100" name="function" value=""></textarea>
		       <table>
		       <tr><td></td><td>yes/no</td></tr>
		       <tr><td>global fit: </td><td><input name="global" type="radio" value="yes">/<input name="global" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>autox: </td><td><input name="autox" type="radio" value="yes">/<input name="autox" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>autoy: </td><td><input name="autoy" type="radio" value="yes">/<input name="autoy" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>autoxy: </td><td><input name="autoxy" type="radio" value="yes">/<input name="autoxy" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>logx: </td><td><input name="logx" type="radio" value="yes">/<input name="logx" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>logy: </td><td><input name="logy" type="radio" value="yes">/<input name="logy" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>ist-ffc: </td><td><input name="ist-ffc" type="radio" value="yes">/<input name="ist-ffc" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>ist-ffc-R1: </td><td><input name="ist-ffc-R1" type="radio" value="yes">/<input name="ist-ffc-R1" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>ist-ffc-R1-err: </td><td><input name="ist-ffc-R1-err" type="text" value="">(float number)</td></tr>
		       <tr><td>stelar-sdf: </td><td><input name="stelar-sdf" type="text" value="">(window range: i:f)</td></tr>
		       <tr><td>stelar-sdf-Re: </td><td><input name="stelar-sdf-Re" type="text" value="">(empty or window range i:f)</td></tr>
		       <tr><td>stelar-sdf-Im: </td><td><input name="stelar-sdf-Im" type="text" value="">(empty or window range i:f)</td></tr>
		       <tr><td>stelar-sef-Mz: </td><td><input name="stelar-sef-Mz" type="radio" value="yes">/<input name="stelar-sef-Mz" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>stelar-sef-R1: </td><td><input name="stelar-sef-R1" type="text" value="">(stelar sef profile filename</td></tr>
		       <tr><td>stelar-sef-R1-err: </td><td><input name="stelar-sef-R1-err" type="text" value="">(float number)</td></tr>
		       <tr><td>stelar-hdf5: </td><td><input name="stelar-hdf5" type="text" value=""></td></tr>
		       <tr><td>stelar-hdf5-Re: </td><td><input name="stelar-hdf5-Re" type="text" value=""></td></tr>
		       <tr><td>stelar-hdf5-Im: </td><td><input name="stelar-hdf5-Im" type="test" value=""></td></tr>
		       <tr><td>stelar-hdf5-R1: </td><td><input name="stelar-hdf5-R1" type="radio" value="yes">/<input name="stelar-hdf5-R1" type="radio" value="no" checked="checked"></td></tr>
		       <tr><td>stelar-hdf5-R1-err: </td><td><input name="stelar-hdf5-R1-err" type="text" value="">(float number)</td></tr>
		       </table>
           	       <button type="submit">fit</button>
            	     </form>
            	     <form action="/convert" method="post" enctype="multipart/form-data">
           	       <button type="submit">convert</button>
            	     </form>
            	     <form action="/list" method="post" enctype="multipart/form-data">
           	       <button type="submit">list models</button>
            	     </form>
            	     <form action="/help" method="post" enctype="multipart/form-data">
           	       <button type="submit">help</button>
		       model: <input name="model" type="text" value="BPP" size=20>
		       key: <input name="key" type="text" values="" size=20>
            	     </form>
            	     <form action="/man" method="post" enctype="multipart/form-data">
           	       <button type="submit">man page</button>
            	     </form>
 
            	  </body>
            	 </html>
HTML
	}
	get -> 'list',*@args {
	     $log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) list");
	     $log-fh.flush;
	     if @args.so { content 'text/plain', "{ MAIN('list',@args.head,:quiet) }\n" }
	     else { content 'text/plain', "{ MAIN('list',:quiet) }\n" }	
	}	
	
	post -> 'list',*@args {
	     $log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) list");
	     $log-fh.flush;
	     if @args.so { content 'text/plain', "{ MAIN('list',@args.head,:quiet) }\n" }
	     else { content 'text/plain', "{ MAIN('list',:quiet) }\n" }	
	}
	
	get -> 'help',*@args {
	     $log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) help");
	     $log-fh.flush;
	     if so @args {
		  if @args.elems > 1 { content 'text/plain', "{ MAIN('help',@args.head, @args.tail, :quiet) }\n" }
		  else { content 'text/plain', "{ MAIN('help',@args.head,:quiet) }\n" }
	     }
	     else { 	content 'text/plain', "tyep model name or model name and key to get help\n" }
	}	
	
	post -> 'help' {
            request-body -> (:$model, *%rest) {
	    	$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) help");
			$log-fh.flush;
	    	if so %rest.kv {
		   for %rest.kv -> $k,$v {
		       if so $v.Str { content 'text/plain', "{ MAIN('help',$model.Str, $v.Str, :quiet) }\n" }
		       else { content 'text/plain', "{ MAIN('help',$model.Str,:quiet) }\n" }
		   }
	    	}
		else { 	content 'text/plain', "{ MAIN('help',$model.Str,:quiet) }\n" }
	    }
	}
	
	get -> 'man', *@args {
	    	$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) help");
			$log-fh.flush;
		   	content 'text/plain', "{ MAIN( man => True ) }\n" 
	}
	
	post -> 'fit',*@args {
            request-body -> (:$file,*%rest) {
	        my $username = "";
	        my $time = now;
    		my $filename = $file.filename;
		my $folder = $filename.IO.extension('').Str;
		my $zip-file = $filename.IO.extension('zip').Str;		
		my $file-to-download = ""; 
		my $function = "";
		my $autox = "";
		my $autoy = "";
		my $autoxy= "";
		my $logx= "";
		my $logy= "";
		my $global="";
		my $ist-ffc = "";
		my $ist-ffc-R1 = "";
		my $ist-ffc-R1-err = "";
		my $stelar-sdf = "";
		my $stelar-sdf-Re = "";
		my $stelar-sdf-Im = "";
		my $stelar-sef-Mz  = "";
		my $stelar-sef-R1 = "";
		my $stelar-sef-R1-err = "";
		my $stelar-hdf5 = "";
		my $stelar-hdf5-Re = "";
		my $stelar-hdf5-Im = "";
		my $stelar-hdf5-R1 = "";
		my $stelar-hdf5-R1-err = "";
		my $num   = +100;
		my $ssz   = +1.0;
		my $fit-methods = "simp scan min minos";
		my $file-content = $file.body-blob;
		my $tmp-folder=10000;
		loop { $tmp-folder = 10000.rand.Int; last unless "./$tmp-folder".so.IO.e }
		my $work-folder = "./$tmp-folder";
#		$filename.IO.spurt: $file-content.decode('UTF-8');
		if so %rest.kv {
		   for %rest.kv -> $k, $v {
		       $fit-methods	      = $v.Str	   if $k eq "fit-methods";
		       $function      	      = $v.Str     if $k eq "function";
		       $num        	      = +$v.Str    if $k eq "Num";
		       $ssz		      = $v.Str	   if $k eq "SymbSize";
		       $username   	      = $v.Str     if $k eq "username";
		       $global      	      = "--global" if $k eq "global"  and $v eq any("yes",1);
		       $autox      	      = "--autox"  if $k eq "autox"  and $v eq any("yes",1);
		       $autoy      	      = "--autoy"  if $k eq "autoy"  and $v eq any("yes",1);
		       $autoxy     	      = "--autoxy" if $k eq "autoxy" and $v eq any("yes",1);
		       $logx       	      = "--logx"   if $k eq "logx" and $v eq any("yes",1);
		       $logy       	      = "--logy  " if $k eq "logy" and $v eq any("yes",1);
		       $ist-ffc		         = "--ist-ffc  " if $k eq "ist-ffc" and $v eq any("yes",1);
		       $ist-ffc-R1        = "--ist-ffc-R1  " if $k eq "ist-ffc-R1" and $v eq any("yes",1);
		       $ist-ffc-R1-err    = "--ist-ffc-R1-err={$v.Rat}  " if $k eq "ist-ffc-R1-err" and $v.^name eq "Rat";
			   $stelar-sdf           = "--stelar-sdf{ $v eq any('yes',1) ?? '' !! '=' ~ $v.Str } " if $k eq "stelar-sdf" and $v !eq "no";
		       $stelar-sdf-Re        = "--stelar-sdf-Re{ $v eq any('yes',1) ?? '' !! '=' ~ $v.Str }  " if $k eq "stelar-sdf-Re" and $v !eq "no";
		       $stelar-sdf-Im        = "--stelar-sdf-Im{ $v eq any('yes',1) ?? '' !! '=' ~ $v.Str }  " if $k eq "stelar-sdf-Im" and $v !eq "no";
		       $stelar-sef-Mz         = "--stelar-sef-Mz  " if $k eq "stelar-sef-Mz" and $v eq any("yes",1);
		       $stelar-sef-R1        = "--stelar-sef-R1  " if $k eq "stelar-sef-R1" and $v eq any("yes",1);
		       $stelar-sef-R1        = "--stelar-sef-R1={$v.Str}  " if $k eq "stelar-sef-R1" and $v.so and $v eq none("yes",1);
		       $stelar-sef-R1-err    = "--stelar-sef-R1-err={$v.Rat}  " if $k eq "stelar-sef-R1-err" and $v.^name eq "Rat";
		       $stelar-hdf5           = "--stelar-hdf5{ $v eq any('yes',1) ?? '' !! '=' ~ $v.Str }  " if $k eq "stelar-hdf5" and $v !eq "no";
		       $stelar-hdf5-Re        = "--stelar-hdf5-Re{ $v eq any('yes',1) ?? '' !! '=' ~ $v.Str }  " if $k eq "stelar-hdf5-Re" and $v !eq "no";
		       $stelar-hdf5-Im        = "--stelar-hdf5-Im{ $v eq any('yes',1) ?? '' !! '=' ~ $v.Str }  " if $k eq "stelar-hdf5-Im" and $v !eq "no";
		       $stelar-hdf5-R1        = "--stelar-hdf5-R1  " if $k eq "stelar-hdf5-R1" and $v eq any("yes",1);
		       $stelar-hdf5-R1-err    = "--stelar-hdf5-R1-err={$v.Rat}  " if $k eq "stelar-hdf5-R1-err" and $v.^name eq "Rat";
		       if $k eq "download" {
		       	  if $v eq "zip" { $file-to-download = $zip-file }
			  elsif $v eq "json" { $file-to-download = "$folder/" ~ $filename.IO.extension('json') }
			  else { $file-to-download = "$folder/$v" }
		       }
		   }
		}
		if any($filename.IO.extension.contains("zip"),$stelar-hdf5.Bool,$stelar-hdf5-Re.Bool,$stelar-hdf5-Im.Bool,$stelar-hdf5-R1.Bool,$stelar-hdf5-R1-err.Bool) {
		   $filename.IO(:bin).spurt: $file-content			
		}
		else {		 
		    $filename.IO.spurt: $file-content.decode('UTF-8')
		}	   

		$username = @args.head ~~ /username/ ?? @args.tail !! @args.head if @args.so;
		$work-folder = "./$username" if $username.so and $username.IO.e;
		$file-to-download = "$work-folder/$file-to-download" if $file-to-download.Bool;
		$zip-file = $zip-file;
		my $txt;
		if so $function {
		   $txt = "onefite fit \"$function\" $filename $global $autox $autoy $autoxy $logx $logy $ist-ffc $ist-ffc-R1 $ist-ffc-R1-err $stelar-sdf $stelar-sdf-Re $stelar-sdf-Im $stelar-sef-Mz $stelar-sef-R1 $stelar-sef-R1-err $stelar-hdf5 $stelar-hdf5-Re $stelar-hdf5-Im $stelar-hdf5-R1 $stelar-hdf5-R1-err --fit-methods=\"$fit-methods\" --Num=$num --work-folder=$work-folder --SymbSize=$ssz --zip-to=$zip-file --save-to=$work-folder/$folder/$folder.json".subst(/\s+/," ",:g);
		   $txt ~= shell("onefite fit \"$function\" $filename $global $autox $autoy $autoxy $logx $logy $ist-ffc $ist-ffc-R1 $ist-ffc-R1-err $stelar-sdf $stelar-sdf-Re $stelar-sdf-Im $stelar-sef-Mz $stelar-sef-R1 $stelar-sef-R1-err $stelar-hdf5 $stelar-hdf5-Re $stelar-hdf5-Im $stelar-hdf5-R1 $stelar-hdf5-R1-err --fit-methods=\"$fit-methods\" --Num=$num --work-folder=$work-folder --SymbSize=$ssz --zip-to=$zip-file --save-to=$work-folder/$folder/$folder.json",:out).out.slurp(:close);
		}
		 else {
		    $txt = "onefite fit $filename $global $autox $autoy $autoxy $logx $logy --fit-methods=\"$fit-methods\" --Num=$num --work-folder=$work-folder --save-to=$work-folder/$folder/$folder.json";
		    $txt ~= shell("onefite fit $filename $global $autox $autoy $autoxy $logx $logy --fit-methods=\"$fit-methods\" --Num=$num --work-folder=$work-folder --save-to=$work-folder/$folder/$folder.json",:out).out.slurp(:close);
		}
		if $file-to-download.Bool { content 'application/octet-stream', $file-to-download.IO.slurp(:bin) }
		else { content 'text/plain', "File '$filename' uploaded and fitted.\n$txt\n" }
		my Bool $tmp-folder-was-created = "./$tmp-folder".IO.e;
   		shell("rm -fr ./$tmp-folder") if "./$tmp-folder".IO.e;		
 		$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) fit { $file.filename } concluded in { now - $time } s. { 'Folder:' ~ $tmp-folder ~ ' removed.' if $tmp-folder-was-created }");
		$log-fh.flush;
	    }
	 }
	 post -> 'convert' {
            request-body -> (:$file, *%rest) {
    		my $filename = $file.filename;
		my $file-content = $file.body-blob;
		$filename.IO.spurt: $file-content.decode('UTF-8');
		my $tmp-folder=10000;
		loop { $tmp-folder = 10000.rand.Int; last unless "./$tmp-folder".so.IO.e }
		my $work-folder = "./$tmp-folder";
		shell "mkdir $work-folder";
		my $file-to-download = $filename.IO.extension.Str ~~ /sav/ ?? $filename.IO.extension('json').Str !! $filename.IO.extension('sav').Str; 
		my $txt = shell("onefite convert $filename $file-to-download --work-folder=$work-folder", :out).out(:close).slurp;
#		content 'text/plain', "$txt\n";
		content 'application/octet-stream', "$file-to-download".IO.slurp(:bin);
		shell "rm -fr $work-folder";
 		$log-fh.say("{ DateTime.now }: ({ request.connection.peer-host }) convert { $file.filename } concluded in { now - $time } s. { 'Folder:' ~ $work-folder ~ ' removed.' }");
		$log-fh.flush;
	     }
	}
    }
     
    say "Starting onefite web service on $ip port $port";
    my Cro::Service $service = Cro::HTTP::Server.new:
			       host => $ip,
			       port => $port,
			       :$application;
    
    $service.start;

    my $log-supply = Supply.interval(60);
    
    react {
	whenever $log-supply {
	    if $log-file.IO.s > 1024*1024 {
		my $now = DateTime.now;
		$log-fh.say("$now - onefite log rotate");
		$log-fh.flush;
		$log-file.IO.rename($log-file ~ ".0");
		try $log-fh = open($log-file, :a) or die "can't open file $!";
	    }
	}
	whenever signal(SIGINT) {
	    $service.stop;
	    $log-fh.close;
	    exit;
	}
    }
}


multi MAIN ('help',
	    Str $model,
	    Bool :q(:$quiet),
	   ){
    my @list = dir(::('OFE-PATH') ~ "/C/local");
    @list.push: dir(::('OFE-PATH') ~ "/C/core/onefit-3.1/modelos").Slip;
    @list = @list.grep(*.f).grep(/\.c/)>>.basename>>.IO>>.extension('').sort;
    my %meta-c = from-json( "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp );	
    my %info = %meta-c{ @list.grep(/$model/).Str };
    my $txt = "$model => " ~ to-json(%info, :sorted-keys);
    say $txt unless $quiet;
    $txt
}

multi MAIN ('help',
	    Str $model,
            Str $key,
	    Bool :q(:$quiet),
	   ){
    my @list = dir(::('OFE-PATH') ~ "/C/local");
    @list.push: dir(::('OFE-PATH') ~ "/C/core/onefit-3.1/modelos").Slip;
    @list = @list.grep(*.f).grep(/\.c/)>>.basename>>.IO>>.extension('').sort;
    my %meta-c = from-json( "{ ::('OFE-PATH') }/C/META-C.json".IO.slurp );	
    my %info = %meta-c{ @list.grep(/$model/).Str };
    my $txt = %info{ $key };
    say $txt unless $quiet;
    $txt
}
 
multi MAIN ('start-engine',
	    Bool :$no-plot,
	    Bool :q(:$quiet)=False, # Don't show log messages
	    Str :$work-folder = '.'
	   ){
    my $supplier = Supplier.new;
    $supplier.Supply.tap: -> $f {
		start {
	    	my $cmd = "plot";
	    	$f ~~ /$<cmd>=(__fit__|__plot__|__fit\-only__)* $<file>=(\S+)/;
	    	my $file = $<file>;
	    	$cmd = $<cmd>.subst('__','',:g);
	    	my $name = $file.subst(/\.sav|\.json/,'',:g);
	    	shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
	    	"$work-folder/$name".IO.mkdir;
	    	$f.IO.move("$work-folder/$name/$file");
	    	my $engine = Engine.new.path("$work-folder/$name").read("$work-folder/$name/$file");
	    	if $cmd ~~ /plot/ {
				my $time = now;
				say "start plotting $file";
				$engine.plot;
				say "finished plotting $file:", now - $time;
	    	}
	    	elsif $cmd ~~ /only/ {
				my $time = now;
				say "start fitting $file";
				$engine.fit(:no-plot($no-plot),:quiet($quiet)).save("$work-folder/$name/$name" ~ "-fit.json");
				say "finished fitting $file:", now - $time;
	    	}
	    	else {
				my $time = now;
				say "start fitting $file";
				$engine.fit(:no-plot($no-plot),:quiet($quiet)).save("$work-folder/$name/$name" ~ "-fit.json");
				say "finished fitting $file:", now - $time;
	    	}
	    	zip-fit($engine,$work-folder,$name);
		}	
    }
    
    while True {
	my @files = dir('.').grep(*.f).grep(/\.sav|\.json/).words;
		for @files -> $file {
	    	if now - $file.IO.changed > 1 { $supplier.emit($file); sleep 1; }
		    else { sleep 1; }
		}
    }
    
}

multi MAIN  ('create',
	     Str  $function is copy,
	     *@data-files where { @data-files.map({ .IO.e or die("$_ doesn't exist!")}) },
	     Str  :data-label(:$data-labels),
         Str  :$fit-methods = "simp scan min minos",
	     Str  :$tags,
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Bool :$global,
	 	 Bool :ist-ffc-Mz(:$ist-ffc) = False,
		 Bool :$ist-ffc-R1 = False,
		 Rat  :$ist-ffc-R1-err,
	   	 Bool :stelar-sdf-Mz(:$stelar-sdf)  = False,
	     Bool :$stelar-sdf-Re  = False,
	     Bool :$stelar-sdf-Im  = False,
	     Bool :stelar-sef-Mz(:$stelar-sef)  = False,
	     Bool :$stelar-sef-R1  = False,
	     Rat  :$stelar-sef-R1-err,
	     Bool :$stelar-hdf5    = False,
	     Bool :$stelar-hdf5-Re = False,
	     Bool :$stelar-hdf5-Im = False,
	     Bool :$stelar-hdf5-R1 = False,
	     Rat  :$stelar-hdf5-R1-err,
	     Str  :SymbSize(:$ssz) where { $_.Rat >= 0 }= '1.0',
	     Str  :save-to(:$to), # write fit settings to json or sav file"
	     Str  :$work-folder = '.',
             Int  :Num(:$npts) = +100
	    ){
    my $name = "ofe-tmp";
    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
    "$work-folder/$name".IO.mkdir unless "$work-folder/$name".IO.e;

	my %options =	'stelar-hdf5' 	 	=> $stelar-hdf5,
					'stelar-hdf5-Re' 	=> $stelar-hdf5-Re,
					'stelar-hdf5-Im' 	=> $stelar-hdf5-Im,
					'stelar-hdf5-R1' 	=> $stelar-hdf5-R1,
					'stelar-hdf5-R1-err'=> $stelar-hdf5-R1-err.so ?? $stelar-hdf5-R1-err !! False,
					'stelar-sdf-Mz'	 	=> $stelar-sdf,
					'stelar-sdf-Re'	 	=> $stelar-sdf-Re,
					'stelar-sdf-Im'	 	=> $stelar-sdf-Im,
					'stelar-sef-Mz'	 	=> $stelar-sef,
					'stelar-sef-R1'	 	=> $stelar-sef-R1,
					'stelar-sef-R1-err' => $stelar-sef-R1-err.so ?? $stelar-sef-R1-err !! False,
					'ist-ffc'			=> $ist-ffc,
					'ist-ffc-R1'		=> $ist-ffc-R1,
					'ist-ffc-R1-err' 	=> $ist-ffc-R1-err.so ?? $ist-ffc-R1-err !! False;


	@data-files = Import.new.path("$work-folder/$name").input-files(@data-files).filter-with(%options);	

	my %aliases = from-json( "{ ::('OFE-PATH') }/../etc/aliases.json".IO.slurp ) if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
    if $function.contains(/^ <ws> \w* <ws> ':' <ws>/) { 
		my $falias = %aliases{ $function.subst(/\s*\w*\s*':'?\s*/,'').subst(/\s+/,' ') };
		if so $falias { $function = $falias }
		else { say "function alias not found in { ::('OFE-PATH') }/../etc/aliases.json"; say %aliases.keys;  }
    }
 
    my %e = parse-function($function.subst(/\n|\r/,'',:g), @data-files,$data-labels, path => "$work-folder/$name");
    %e<FitMethods> = $fit-methods;
    %e<FitType>="Global" if $global;
    %e<Num>=$npts;
    %e<SymbSize>=$ssz.Rat;
    my $engine = Engine.new.path("$work-folder").set(%e);
    $engine.blocks(
	:read,
	:fit,
	:export,
	:autox($autox),
	:autoy($autoy),
	:logx($loglin or $loglog),
	:logy($linlog or $loglog));
    $engine.parameters(:read).functions(:read).stp.code(:write,:compile);
    %e=$engine.h;
    %e<par-tables>:delete;
    if $to.defined { $engine.set(%e).save($to) }
    else { say to-json(%e, :sorted-keys) }
    exit;
}

multi MAIN  ('random',
	     Str  $function, 
	     *@data-files where { @data-files.map({ .IO.e or die("$_ doesn't exist!")}) },
	     Str  :data-label(:$data-labels),
	     Str  :$tags,
	     Str  :$zip-to,
	     Bool :$no-plot,
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Bool :$global,
	     Str  :$save-to, # write fit settings to json or sav file 
	     Str  :$work-folder = '.',
	     Int  :Num(:$npts) = +100
	    ){
    my %e = parse-function($function.subst(/\n|\r/,'',:g), @data-files,$data-labels);
    %e<FitType>="Global" if $global;
    %e<Num>=$npts;
    for %e.kv -> $k, $v {
	if all($k.contains("Pval"), %e{$k.subst('val','max')}.Bool, %e{$k.subst('val','min')}.Bool) {
	    $k ~~ /Pval $<i>=(\d+)/;
	    %e{$k}= (%e{$k.subst('val','min')}.Real .. %e{$k.subst('val','max')}.Real).rand;
	    %e{'F' ~ $<i>.Str}= "Fix";
	}
    }
    my $name = "ofe-tmp";
    if $zip-to.Bool {
	$name = $zip-to.subst(/\.zip/,'',:g);
    }
    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
    "$work-folder/$name".IO.mkdir;
    for @data-files { $_.IO.copy("$work-folder/$name/$_") };
    my $engine = Engine.new.path("$work-folder/$name").set(%e);
    $engine.fit(
	:no-plot($no-plot),
	:autox($autox or $autoxy),
	:autoy($autoy or $autoxy),
	:logx($loglin or $loglog),
	:logy($linlog or $loglog)
    );
    $engine.save($save-to) if $save-to.defined;
    zip-fit($engine,$work-folder,$name) if $zip-to.Bool;
#    shell "pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
    exit;
}

multi MAIN  ('fit',
	     Str  $function is copy, 
	     *@data-files where { @data-files.map({ .IO.e or die("$_ doesn't exist!")}) },
	     Str  :data-label(:$data-labels),
         Str  :$fit-methods = "simp scan min minos",
	     Str  :$tags,
	     Str  :$zip-to,
	     Bool :$no-plot,
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Bool :$global,
		 Str  :$ist = "",
		 Str  :$stelar = "",
	     Str  :SymbSize(:$ssz) where { $_.Rat >= 0 }= '1.0',
	     Str  :$save-to, # write fit settings to json or sav file 
	     Str  :$work-folder = '.',
	     Int  :Num(:$npts) = +100,
		 *%_
	    ){
    my $name = "ofe-tmp";
    if $zip-to.Bool {
		$name = $zip-to.subst(/\.zip/,'',:g);
    }
    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
    "$work-folder/$name".IO.mkdir unless "$work-folder/$name".IO.e;
  say $stelar;
 	my %sub-options = $stelar.so ?? $stelar.split(/<[:\s]>+/) !! $ist.so ?? $ist.split(/<[:\s]>+/) !! ""; 
	say "su option: ",%sub-options;
	say "extre ",%_;
	my %options =	'stelar' 	 	=> $stelar.so ?? $stelar !! False,
					'ist'			=> $ist.so ?? $ist !! False;

    %options = %options,%sub-options;
	say "previous+sub:",%options;
	%options = %options,%_;
	say "all: ",%options;
	@data-files = Import.new.path("$work-folder/$name").input-files(@data-files).filter-with(%options);	
    
	my %aliases = from-json( "{ ::('OFE-PATH') }/../etc/aliases.json".IO.slurp ) if  "{ ::('OFE-PATH') }/../etc/aliases.json".IO.e;
    if $function.contains(/^ <ws> \w* <ws> ':' <ws>/) {
		my $falias = %aliases{ $function.subst(/\s*\w*\s*':'?\s*/,'').subst(/\s+/,' ') };
		if so $falias { $function = $falias }
		else { say "function alias not found in { ::('OFE-PATH') }/../etc/aliases.json"; say %aliases.keys;  }
    }
    my %e = parse-function($function.subst(/\n|\r/,'',:g), @data-files,$data-labels, path => "$work-folder/$name");
    %e<FitMethods> = $fit-methods;
    %e<FitType>="Global" if $global;
    %e<Num>=$npts;
    %e<SymbSize>=$ssz.Rat;
    my $engine = Engine.new.path("$work-folder/$name").set(%e);
    $engine.fit(
	:no-plot($no-plot),
	:autox($autox or $autoxy),
	:autoy($autoy or $autoxy),
	:logx($loglin or $loglog),
	:logy($linlog or $loglog)
    );
    $engine.save($save-to) if $save-to.defined;
    zip-fit($engine,$work-folder,$name) if $zip-to.Bool;

    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";

    exit;
}

multi MAIN  ('fit',
	     Str  $input-file where { $input-file.IO.e or die "$input-file dosen't exist!" }, # name of the (sav or json) to compile
         Str  :$fit-methods = "simp scan min minos",
	     Bool :$no-plot,
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Str  :save-to(:$to), # write fit settings to .json or .sav file 	     
	     Str  :$zip-to = $input-file.IO.extension('').Str,
	     Str  :$work-folder = '.',
	     Int  :Num(:$npts)
	    ){
	    my $name = $input-file.subst(/\.sav|\.json/,'',:g);
	    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
	    "$work-folder/$name".IO.mkdir;
	    $input-file.IO.copy("$work-folder/$name/$input-file");
	    my $engine = Engine.new.path("$work-folder/$name").read("$work-folder/$name/$input-file");
#	    my $engine = OFE::Engine.new.path("$work-folder").read($input-file);
	    $engine.Num($npts) if $npts.Bool;
	    $engine.fit-methods($fit-methods);
	    $engine.fit(
		:no-plot($no-plot),
		:autox($autox or $autoxy),
		:autoy($autoy or $autoxy),
		:logx($loglin or $loglog),
		:logy($linlog or $loglog)
	    );
	    $engine.save($to) if $to.defined;
	    zip-fit($engine,$work-folder,$name);
	    shell "mv $name.zip $zip-to" unless $name eq $zip-to;
	    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
	    exit;
}


multi MAIN  ('plot',
	     Str $input-file where { $input-file.IO.e or die "$input-file dosen't exist!" }, # name of the (sav or json) to compile
	     Bool :$autox,
	     Bool :$autoy,
	     Bool :$autoxy,
	     Bool :logy(:$linlog),
	     Bool :logx(:$loglin),
	     Bool :logxy(:$loglog),
	     Str  :$work-folder = '.',
	     Int  :Num(:$npts)
	    ){
	    my $name = $input-file.subst(/\.sav|\.json/,'',:g);
	    shell "rm -fr $work-folder/$name" if "$work-folder/$name".IO.d;
	    "$work-folder/$name".IO.mkdir;
	    $input-file.IO.copy("$work-folder/$name/$input-file");
	    my $engine = Engine.new.path("$work-folder/$name").read("$work-folder/$name/$input-file");
	    #	    my $engine = Engine.new.path("$work-folder").read($input-file);
	    $engine.Num($npts) if $npts.Bool;
	    $engine.plot(
		:autox($autox or $autoxy),
		:autoy($autoy or $autoxy)
		:logx($loglin or $loglog),
		:logy($linlog or $loglog)
	    );
	    zip-fit($engine,$work-folder,$name);
	    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
	    exit;
}


multi MAIN ('test','list') {
    my $test-path=OFE-PATH ~ "/t";
#    my $test-path=OFE-PATH.subst("rakumod/OFE","t");
    dir($test-path).grep(*.f).grep(/rakutest/).map( { .subst("$test-path/","",:g).say });
}	    

multi MAIN ('test',
	    *@arr,
	    Bool :verbose(:$v) = False
	   ){
    my $test-path=OFE-PATH ~ "/t";
#    my $test-path=OFE-PATH.subst("rakumod/OFE","t");

    "/tmp/OneFit-Engine-test".IO.mkdir unless "/tmp/OneFit-Engine-test".IO.d(:e);
    
    if @arr.elems > 0 {
	my $fho = open :w, 'tests.log';
	@arr.race.map(
	    {
		my $test = "$_.rakutest" unless .contains(/rakutest/);
		say "testing....$test"; run "raku", "$test-path/$test" , :err<fho>
	    }
	);
	$fho.close;
	"tests.log".IO.slurp.say;
    }
    else {
	my $proc = run "prove6", "--lib", "$test-path","--err=ignore";
    }
    run-post-install-tests(:verbose($v));
    exit;
}

sub parse-function ($function, @data-files, $data-labels, Str :$path = ".") {
    my %e = OneFit::Engine::Grammars::Function.parse-me($function);
    %e<FitType T Num> = <Individual dum 100>;
    %e<SelectedDataSet> = @data-files[0].subst(".dat","");
    for (1 .. @data-files.elems) {
	my @lines="$path/{@data-files[$_-1]}".IO.lines;
	my $label = "dum";
	my $dum=$_;
	$dum = @lines.head if @lines.head.words.elems < 2;
	if @lines.grep(/DATA/) {
	    $label = @lines.grep(/DATA/).split("=")[0].split("DATA")[1].words[0];
	    $dum = @lines.grep(/DATA/).split("=")[1];
	    %e<T> = $label;
	    shift @lines;
	}
	if @lines.grep(/TAG/) {
	    shift @lines;
	}
	if $data-labels.defined {
	    my $dum-parse = OneFit::Engine::Grammars::Label.parse($data-labels);
	    $label = $dum-parse<name>.Str;
	    %e<T> = $label;
	    if $dum-parse<values> > 0 { $dum = $dum-parse<values>[$_-1].Str.join(' ') }
	}
	%e<Dados> ~= "\n# DATA $label = $dum\n";
	%e<Dados> ~= "# TAG = { @data-files[$_-1].subst(".dat","") }\n";
	%e<Dados> ~= @lines.join("\n") ~ "\n\n";
	%e<Tags>.push: @data-files[$_-1].subst(".dat","");
    }
    return %e;
}

sub zip-fit ($engine,$work-folder,$name) {
    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
    my $excluded =  { "$work-folder/$name/" <<~<< <AuxCode.* onefit-user *.h *.c *.o *_ gnu* *.stp> }().join(' ') ;
    "$name.zip".IO(:e).unlink;
    shell "cd $work-folder/$name && pdftk { 'fit-curves-' <<~<< (1 ... $engine.blocks(:a).elems) >>~>> '.pdf' } cat output ./All.pdf";
    shell "zip -q -r $work-folder/$name.zip $work-folder/$name -x $excluded";
}

sub run-post-install-tests(Bool :$verbose = False) {
    my $data = q:to/EOT/;
# DATA dum = 40616
# TAG = zone12
# R1 = 16.9554
2.4 0.4950845801988824 1
1.60968 0.5030929382053178 1
1.07962 0.5071383400239955 1
0.724101 0.5192948321930172 1
0.485656 0.5160022771910805 1
0.32573 0.5291235757829099 1
0.218468 0.5350239458592603 1
0.146527 0.5898993575693909 1
0.098276 0.6180204586347606 1
0.065914 0.6826722682863811 1
0.044208 0.752954560068173 1
0.029651 0.8279391722256552 1
0.019887 0.8918345724621874 1
0.013338 0.9470250641189731 1
0.008946 0.9713798167045512 1
0.006 1.0 1.0 
EOT


        say "Running post-install tests...\n";
        "/tmp/zone12.dat".IO.spurt: $data;
	my $service = shell("systemctl status onefite",:out).out.slurp(:close).contains("active (running)");
	if $service {
	    put "testing localhost onefite web service... ";
	    my $result = "curl --silent -F \"file=\@zone12.dat\" -F \"stelar-hdf5=no\" -F \"autox=yes\" -F \"logx=yes\" -F \"function=Mz[-2<2](t,M0,Mi,T1[0.01<3])=Mi \+ (M0-Mi)*exp(-t/T1)\" http://127.0.0.1:8142/fit --output ofe-test.log";
	    say $result if $verbose;
	    $result = shell("cd /tmp && $result");
	    $result = "/tmp/ofe-test.log".IO.slurp(:close);
	    say $result if $verbose;
	    if $result.contains("zone12, 16") {
		put "OK\n";
	    }
	    else {
		put "error!\n";
	    }
	}
	else {
	    say "onefite service if off in all ports";
	}
	my &fileowner = { my $file = $^a; shell("ls { $file.IO.d ?? '-ld' !! '-la'} $file | awk '\{print \$3\}'",:out).out.slurp(:close) };
	</tmp/ofe-tmp>.map({ $_.IO.e and fileowner($_).contains("root") ?? shell("sudo rm -fr $_") !! shell("rm -fr $_") });

	put "testing command line onefite...";
	my $result = shell("cd /tmp/ && onefite fit \"Mz[-2<2](t,M0,Mi,T1[0.01<3])=Mi \+ (M0-Mi)*exp(-t/T1)\" zone12.dat --no-stelar-hdf5 --autox --logx", :out).out.slurp(:close);
	say $result if $verbose;
	if $result.contains("zone12, 16") {
	    put "OK\n";
	}
	else {
	    put "error!\n\n";
	}
#	$SUDO = "sudo" if any( (fileowner("/tmp/ofe-tmp"), fileowner("/tmp/ofe-test.log"), fileowner("/tmp/OneFit-Engine-test"), fileowner("/tmp/zone12.dat"))>>.contains("root"));
#	shell "$SUDO rm -fr /tmp/ofe-tmp /tmp/OneFit-Engine-test /tmp/zone12.dat /tmp/ofe-test.log " if "/tmp/zone12.dat".IO.e;
	</tmp/ofe-tmp /tmp/OneFit-Engine-test /tmp/zone12.dat /tmp/ofe-test.log>.map({ $_.IO.e and fileowner($_).contains("root") ?? shell("sudo rm -fr $_") !! shell("rm -fr $_") });
}


=begin pod

=NAME 
	onefite - Raku script interface to the OneFit-Engine (OFE)

=SYNOPSIS
=begin code :lang<bash>
onefite [-h|--help]
onefite uninstall
onefite service start
onefite service stop
onefite service log
onefite service PID
onefite list [-q|--quiet]
onefite list models [-q|--quiet]
onefite list aliases [-q|--quiet]
onefite path [-s|--src] [-t] [-e|--examples] [-b|--bin] [-l|--lib] [-c|-C] [--log]
onefite convert <input-file> <output-file> [--work-folder=<Str>]
onefite upgrade [-u|--to-user] [-c|--compile] [-d|--systemd-daemon] [--test=<Str>] [--ip=<Str>] [-p|--port[=Int]] [-m|--merge-site=<Str>] [--cernlib] [--shell] [--shell-port=<Int>]
onefite start-web-engine [--ip[=Any]] [-p|--port[=Any]]
onefite stop-web-engine
onefite help <model> [-q|--quiet]
onefite help <model> <key>] [-q|--quiet]
onefite start-engine [--no-plot] [-q|--quiet] [--work-folder=<Str>]
onefite create <function> [<data-files> ...] [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--stelar-hdf5] [--ist-ffc] [--ist-ffc-R1] [--ist-ffc-R1-err=<Rat>] [--stelar-sdf] [--stelar-sdf-Re] [--stelar-sdf-Im] [--stelar-sef] [--stelar-sef-R1] [--stelar-sef-R1-err=<Rat>] [--stelar-hdf5-Re] [--stelar-hdf5-Im] [--stelar-hdf5-R1] [--stelar-hdf5-R1-err=<Rat>] [--SymbSize|--ssz=<Str>] [--save-to|--to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
onefite random <function> [<data-files> ...] [--data-label|--data-labels=<Str>] [--tags=<Str>] [--zip-to=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--save-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
onefite fit <function> <data-files> ... [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--zip-to=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--ist-ffc] [--ist-ffc-R1] [--ist-ffc-R1-err=<Rat>] [--stelar-sdf[=<Str>]] [--stelar-sdf-Re[=<Str>]] [--stelar-sdf-Im[=<Str>]] [--stelar-sef] [--stelar-sef-R1[=<Str>]] [--stelar-sef-R1-err=<Rat>] [--stelar-hdf5] [--stelar-hdf5-Re] [--stelar-hdf5-Im] [--stelar-hdf5-R1] [--stelar-hdf5-R1-err=<Rat>] [--SymbSize|--ssz=<Str>] [--save-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
onefite fit <input-file> [--fit-methods=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--save-to|--to=<Str>] [--zip-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
onefite plot <input-file> [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--work-folder=<Str>] [--Num|--npts[=Int]]
onefite test list
onefite test [<arr> ...] [--verbose|-v]
=end code

=NOTE
	This man page is expected to help you to take full advanatge of onefite both on the server and on the client sides
	


=DESCRIPTION 
		this is it

=USAGE

=head2 Basic commands

=item1 onefite
=begin code :lang<bash>
onefite [-h|--help]
=end code

	Options

	[-h|--help] Basic help

=item1 Uninstall
=begin code :lang<bash>
 onefite uninstall
=end code

=item1 Help on models
=begin code :lang<bash>
 onefite help <model> [-q|--quiet]
 onefite help <model> <key>] [-q|--quiet]
=end code
	
	Provides information on the <model> equation included in the models fitting library
	Sub-option <key> provides just the specific information on the key 

	Options

	[-q|--quiet] No screen print of log information 

=item1 List models
=begin code :lang<bash>
onefite list [-q|--quiet]
onefite list models [-q|--quiet]
onefite list aliases [-q|--quiet]
=end code
	
	Lists models included in the models fitting library and aliases defined in $HOME/.local/etc/aliases.json)i
	Lists just the models
	Lists just the aliases

	Options

	[-q|--quiet] No screen print of log information 

=item1 Paths finder
=begin code :lang<bash>
onefite path [-s|--src] [-t] [-e|--examples] [-b|--bin] [-l|--lib] [-c|-C] [--log] [-a|--aliases]
=end code

	Paths to OneFit-Engine folders installed. 
	Combined use with "cd" and "awk" in the examples below

	Options

	[-s|--src] Source
	[-t] Raku test folder
	[-e|--examples] Examples folder
	[-b|--bin] Binaries folder
	[-l|--lib] Libraries folder
	[-c|-C] C code/F code folders
	[--log] Log folder
	[-a|--aliases] Aliases folder
	
	Examples

	cd $(onefite path -s)
	vi $(onefite path -a)/aliases.json

=head2 Files conversion

=item1 sav <--> json files conversion
=begin code :lang<bash>
onefite convert <input-filename> <output-filename> [--work-folder=<Str>]
=end code
	
	Converts fitteia's sav files to OFE json files

	Options

	[--work-folder] Folder where the coversion will be performed

	Examples
	
	onefite convert some-fitteia-fit.sav ofe-version.json


=head2 OFE service commands

=item1 Systemd service 

=begin code :lang<bash>
onefite service start
onefite service stop
=end code

	[start] Is: sudo systemctl daemon-reload; systemctl enable onefite.service; service onefite start
	[stop] Is: kill -9 <star-web-service>

=item1 LOG and PID services

=begin code :lang<bash>
onefite service log|PID
=end code

	Shows log OFE service log file	
	Prints OFE Process IDentifier 

=item OFE manual web service

=begin code :lang<bash>
onefite start-web-engine [--ip[=Any]] [-p|--port[=Any]]
onefite stop-web-engine
(OBSOLETE) onefite start-engine [--no-plot] [-q|--quiet] [--work-folder=<Str>]
=end code

	User command line to start|stop OFE web service

=head2 Create command

=begin code :lang<bash>
onefite create <function> <data-files> ... [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--stelar-hdf5] [--ist-ffc] [--ist-ffc-R1] [--ist-ffc-R1-err=<Rat>] [--stelar-sdf] [--stelar-sdf-Re] [--stelar-sdf-Im] [--stelar-sef] [--stelar-sef-R1] [--stelar-sef-R1-err=<Rat>] [--stelar-hdf5-Re] [--stelar-hdf5-Im] [--stelar-hdf5-R1] [--stelar-hdf5-R1-err=<Rat>] [--SymbSize|--ssz=<Str>] [--save-to|--to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]
=end code

	Creates a json file with the function and datafiles provided.

	Function

	The function syntax has the follwing rules:
		[ x < y ] Defines a range of vales [ x ; y], that is between x and y, inclusive. Spaces can be removed. '<' and ';' can be use as limits separators but '<' present less escape issues in argument passing   
    	':'	Initializing symbol
		'=' Fix a value

	Example

		"Mz [ -1 < 1] ( t[1e-3 < 10], M0:0.5[-1<1], Mi=1[-2<2], T1:0.5 [ 1e-3 < 10]) = Mi \+ (M0-Mi)*exp(-t/T1)"
		Mz is the dependent variable with a plot range will be form -1 to 1. Mz is a function with arguments: t,M0,Mi, and T1
		t  is the independent variable with a plot range between 1e-3 and 10
		M0 is a model parameter initiallized to 0.5 and the non linier Least-Squares minimization performed by CERN lib MINUIT will be restrited to the range [-1;1]
		Mi is a model parameter with a fixed value 1 but a possible range [-2;2]
		T1 is a model parameter initialized to 0.5 in a range [1e-2; 10]
	
		The expression "Mi \+ (M0-Mi)*exp(-t/T1)" contains '\+' that sets the plotting individual model contributions option to True

	Options




=head2 Fit commands

=begin code :lang<bash>
onefite create <function> <data-files> ... [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--stelar-hdf5] [--ist-ffc] [--ist-ffc-R1] [--ist-ffc-R1-err=<Rat>] [--stelar-sdf] [--stelar-sdf-Re] [--stelar-sdf-Im] [--stelar-sef] [--stelar-sef-R1] [--stelar-sef-R1-err=<Rat>] [--stelar-hdf5-Re] [--stelar-hdf5-Im] [--stelar-hdf5-R1] [--stelar-hdf5-R1-err=<Rat>] [--SymbSize|--ssz=<Str>] [--save-to|--to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]

onefite random <function> <data-files> ... [--data-label|--data-labels=<Str>] [--tags=<Str>] [--zip-to=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--save-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]

onefite fit <function> <data-files> ... [--data-label|--data-labels=<Str>] [--fit-methods=<Str>] [--tags=<Str>] [--zip-to=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--global] [--ist-ffc] [--ist-ffc-R1] [--ist-ffc-R1-err=<Rat>] [--stelar-sdf[=<Str>]] [--stelar-sdf-Re[=<Str>]] [--stelar-sdf-Im[=<Str>]] [--stelar-sef] [--stelar-sef-R1[=<Str>]] [--stelar-sef-R1-err=<Rat>] [--stelar-hdf5] [--stelar-hdf5-Re] [--stelar-hdf5-Im] [--stelar-hdf5-R1] [--stelar-hdf5-R1-err=<Rat>] [--SymbSize|--ssz=<Str>] [--save-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]]

onefite fit <input-file> [--fit-methods=<Str>] [--no-plot] [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--save-to|--to=<Str>] [--zip-to=<Str>] [--work-folder=<Str>] [--Num|--npts[=Int]

onefite plot <input-file> [--autox] [--autoy] [--autoxy] [--logy|--linlog] [--logx|--loglin] [--logxy|--loglog] [--work-folder=<Str>] [--Num|--npts[=Int]]

=end code

=head2 Version upgrade

=begin code
onefite upgrade [-u|--to-user] [-c|--compile] [-d|--systemd-daemon] [--test=<Str>] [--ip=<Str>] [-p|--port[=Int]] [-m|--merge-site=<Str>] [--cernlib] [--shell] [--shell-port=<Int>]
=end code

	At the host prompt run I<onefite updatde -d --shell --test>  

	This will upgrade the current (main or dev) version of the OneFit-Engine. github.com/fitteia/OneFit-Engine.git 
	is downloaded and expanded. OneFit-Engine/INSTALL is called with options --system-daemon and --shell an --test options.  
	Port 8142 will be open to onefite requests.
	Port 8100 will be open to shell command accces via a web browser 

	Options
	
	[-c|--compile] Compile the OneFit-Engine C and F source.  Default is True
	[--ip] Ip range access to the OneFit-Engine web service. Default '*' (All)
	[-p] Port number for the OneFit-Engine web service. Default 8142
	[-m|--merge-site] Git pull OneFit-Engine and merge with local site sources. Default True

	[-u|--to-user] Install OneFit-Engine in the user space.  Default is False
	[-d|--systema-daemon] Create a systemd service.config and install service.  Default is False
	[--test] Run install tests.  Default False
	[--cernlib] Use debian cernlib package or compile fortran version from source. Default False
	[--shell] Install debian package to create a wes shell service on defaul port 8100 or port define in option --shell-port. Default False
	[--shell-port] Port number for the web shell service. Default 8100

	Use --/<option> or --no-<option> for disable default option value (ex: --no-test or --/test)	

=head2 Test commands

=begin code :lang<bash>
onefite test list

onefite test [<arr> ...] [--verbose|-v]
=end code
=PARAMETERS
=head2 File parameters
=item input-file- name of the file to be converted (file extensions: sav or json)
=item output-file- name of the converted file (file extensions: sav or json)

=head2 Fit methods
=item fit-methods - simp scan min minos


=para 
this is the first example

=end pod


